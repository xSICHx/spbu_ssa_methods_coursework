---
title: "SSA methods"
author: "Погребников Николай"
output:
  html_notebook:
    toc: true
    toc_float: true
    number_sections: true
    toc_depth: 4
---

```{r}
afc <- function(filter, omega) {
  k <- seq_along(filter) - 1 #значения от 0 до length(filter) - 1
  h <- function(o) sum(rev(filter) * exp(-k*1i * o))
  abs(sapply(omega, h))
}

freq <- seq(0, pi, 0.00001)

filt <- rep(1, 100)
# filt <- c(-1,1)
# filt <- c(-1,2,-1)

omega <- freq/2/pi

plot(afc(filt, freq) ~ omega, type = "l")
```

Построим фильтр из GSSA

```{r}
library(ggplot2)
library(latex2exp)
# Установим длину L
L <- 100
n <- 1:L

# Функция для вычисления весов w
w_func <- function(alpha, n, L) {
  (abs(sin(pi * n / (L + 1))))^alpha
}

# Данные для разных alpha
w_alpha0 <- w_func(0, n, L)
w_alpha05 <- w_func(0.5, n, L)
w_alpha1 <- w_func(1, n, L)

# Один график с тремя линиями
plot(n, w_alpha0, type = "l", col = "blue", lwd = 2,
     xlab = TeX("$n$"),  # LaTeX для оси X
     ylab = TeX("$w$"),  # LaTeX для оси Y
     ylim = c(0, 1),
     main = TeX("Веса при различных значениях $\\alpha$"))  # LaTeX в заголовке
lines(n, w_alpha05, col = "red", lwd = 2)
lines(n, w_alpha1, col = "green", lwd = 2)

# Легенда с LaTeX
legend("topright", legend = c(TeX("$\\alpha = 0$"), TeX("$\\alpha = 0.5$"), TeX("$\\alpha = 1$")),
       col = c("blue", "red", "green"), lwd = 2)
```

```{r}

L <- 81

freq <- seq(0, pi, 1/1000)

x <- 1:L

filt <- sqrt(sin(pi*x/(L+1))^2)**(1)

omega <- freq/2/pi


plot(afc(filt, freq) ~ omega, type = "l")
```

### WOSSA

```{r}
library(Rssa)
```

```{r}
ssa
```

```{r}

methods(class = "wossa")


```

```{r}
Rssa:::decompose.wossa
```

```{r}
n <- 96*2-1
x <- 0:(n-1)
L <- 50
y1 <- sin(2*pi/12 * x)
y2 <- cos(2*pi/3 * x)/2
y3 <- exp(x/100) + 1
y <- y1 + y2 + y3
alpha <- 1/2
filt <- sqrt(sin(pi * 1:(L) / (L + 1))^2)^alpha

  
s <- ssa(y, L)
r <- reconstruct(s, groups = list(
  e = c(1),
  s1 = 2:3,
  s2 = 4:5
))

sw <- ssa(y, L, col.oblique = filt, row.oblique = rep(1, n-L+1))
rw <- reconstruct(sw, groups = list(
  e = c(1),
  s1 = 2:3,
  s2 = 4:5
))

mse <- function(f_true, f_reconstructed){
   mean((f_true - f_reconstructed)^2) 
}

mse(r$s2, rw$s2)
mse(r$e, y3)
mse(rw$e, y3)
# mse()

# plot(rw$e)
# lines(y3, col="red")
```

### GSSA

```{r}
library(Rssa)

gssa <- function(ts, L, alpha = 0){
  N <- length(ts)
  tmp <- 1:(L)
  w <- sqrt(sin(pi*tmp/(L+1))^2)**alpha
  X <- diag(w) %*% hankel(ts, L)
  K <- dim(X)[2] 
  X_t <- t(X)
  S <- X %*% X_t
  
  tmp <- eigen(S)
  lambda <- tmp$values
  lambda <- lambda[lambda > 0]
  d <- length(lambda)
  U <- tmp$vectors[, 1:d]
  
  
  get_V_i <- function(i){
    X_t %*% U[, i] / sqrt(lambda[i])
  }
  
  get_X_i <- function(i){
    sqrt(lambda[i]) * as.matrix(U[, i]) %*% t(as.matrix(get_V_i(i)))
  }
  
  X_mats <- lapply(1:d, get_X_i)
  
  create_A_alpha <- function(){
    A <- c()
    for (i in 1:N){
      if (i <= L-1){
        A <- c(A, sum(w[1:i]))
      }
      else if (L <= i & i <= K){
        A <- c(A, sum(w))
      }
      else{
        A <- c(A, sum(w[(i-K+1):L]))
      }
    }
    A
  }
  
  A_alpha <- create_A_alpha()
  
  # A_alpha |> print()
  
  
  mean_w <- function(x){
    sum(x)/A_alpha[length(x)]
  }
  
  diag_averaging_w <- function(A){
    B <- A[nrow(A):1, ] |> Re()
    lapply(split(B, -(row(B) - col(B)) ), mean_w) |> as.numeric()
  }
  
  reconstr_elementary <- function(){
    lapply(X_mats, diag_averaging_w)
  }
  
  r_elem <- reconstr_elementary()
  # r_elem |> print()
  
  return(
    list(
      ts = r_elem,
      lambda = lambda
    )
  )
  
}




# plot(Reduce("+", r_gssa$ts), type="l", lwd =3)
# lines(y, col="red")
```

```{r}
get_middle_point_filters <- function(ts, L, alpha = 0){
  N <- length(ts)
  tmp <- 1:(L)
  w <- sqrt(sin(pi*tmp/(L+1))^2)^alpha
  X <- diag(w) %*% hankel(ts, L)
  K <- dim(X)[2] 
  X_t <- t(X)
  S <- X %*% X_t
  
  tmp <- eigen(S)
  lambda <- tmp$values
  lambda <- lambda[lambda > 0]
  d <- length(lambda)
  U <- tmp$vectors[, 1:d]
  
  weight <- sum(w)
  
  get_filter_i <- function(i){
    filt <- c()
    u <- U[, i]
    
    get_sum_j <- function(j){
      sm <- 0
      for ( k in 1:(L-abs(j)) ){
        sm <- sm + u[k]*u[k+abs(j)]*w[k]
      }
      sm / weight
    }
    
    lapply( (-(L-1)):(L-1), get_sum_j ) |> unlist()
  }
  
  lapply(1:d, get_filter_i)
  
  
}
```

#### ! sin + cos + хорошее L

```{r}
n <- 96*2-1
x <- 0:(n-1)
L <- 48
y1 <- sin(2*pi/12 * x)
y2 <- cos(2*pi/3 * x)/2
y <- y1 + y2
alpha <- 1/2
filt <- sqrt(sin(pi * 1:(L) / (L + 1))^2)^alpha

  
s <- ssa(y, L)
r <- reconstruct(s, groups = list(
  s1 = 1:2,
  s2 = 3:4
))

sw <- ssa(y, L, col.oblique = filt, row.oblique = rep(1, n-L+1))
rw <- reconstruct(sw, groups = list(
  s1 = 1:2,
  s2 = 3:4
))

mse <- function(f_true, f_reconstructed){
   mean((f_true - f_reconstructed)^2) 
}


r_gssa <- gssa(y, L, alpha = alpha)

# mse(rw$e, r_gssa$ts[[1]])
# mse(r$s1, y1)
# mse(rw$s1, y1)
# mse(r_gssa$ts[[1]] + r_gssa$ts[[2]], y1)


# Create a data frame to store MSE values
mse_table <- data.frame(
  Method = c("r", "rw", "r_gssa"),
  MSE_y1 = c(mse(r$s1, y1),
             mse(rw$s1, y1),
             mse(r_gssa$ts[[1]] + r_gssa$ts[[2]], y1)),
  MSE_y2 = c(mse(r$s2, y2),
             mse(rw$s2, y2),
             mse(r_gssa$ts[[3]] + r_gssa$ts[[4]], y2)),
  MSE_y = c(mse(r$s1 + r$s2, y1 + y2),
                     mse(rw$s1 + rw$s2, y1 + y2),
                     mse(r_gssa$ts[[1]] +
                           r_gssa$ts[[2]] +
                           r_gssa$ts[[3]] +
                           r_gssa$ts[[4]], y1 + y2))
)

mse_table |> print()

freq <- seq(0, pi, 0.001)
omega <- freq/2/pi

filters <- get_middle_point_filters(y1, L, alpha = 0)
filt <- filters[[1]] + filters[[2]]

plot(afc(filt, freq) ~ omega, type = "l")
abline(v = 1/12, col = "red")

filters <- get_middle_point_filters(y1, L, alpha = alpha)
filt <- filters[[1]] + filters[[2]]

lines(afc(filt, freq) ~ omega, col ="blue")
```

```{r}
n <- 96*2-1
x <- 0:(n-1)
L <- 48
w1 <- 1/19
y1 <- sin(2*pi/12 * x)
y2 <- cos(2*pi*w1 * x)/2
y <- y1 + y2
alpha <- 1/2
filt <- sqrt(sin(pi * 1:(L) / (L + 1))^2)^alpha

  
s <- ssa(y, L)
r <- reconstruct(s, groups = list(
  s1 = 1:2,
  s2 = 3:4
))

sw <- ssa(y, L, col.oblique = filt, row.oblique = rep(1, n-L+1))
rw <- reconstruct(sw, groups = list(
  s1 = 1:2,
  s2 = 3:4
))

mse <- function(f_true, f_reconstructed){
   mean((f_true - f_reconstructed)^2) 
}


r_gssa <- gssa(y, L, alpha = alpha)

# mse(rw$e, r_gssa$ts[[1]])
# mse(r$s1, y1)
# mse(rw$s1, y1)
# mse(r_gssa$ts[[1]] + r_gssa$ts[[2]], y1)


# Create a data frame to store MSE values
mse_table <- data.frame(
  Method = c("SSA", "rw", "GSSA"),
  MSE_y1 = c(mse(r$s1, y1),
             mse(rw$s1, y1),
             mse(r_gssa$ts[[1]] + r_gssa$ts[[2]], y1)),
  MSE_y2 = c(mse(r$s2, y2),
             mse(rw$s2, y2),
             mse(r_gssa$ts[[3]] + r_gssa$ts[[4]], y2)),
  MSE_y = c(mse(r$s1 + r$s2, y1 + y2),
                     mse(rw$s1 + rw$s2, y1 + y2),
                     mse(r_gssa$ts[[1]] +
                           r_gssa$ts[[2]] +
                           r_gssa$ts[[3]] +
                           r_gssa$ts[[4]], y1 + y2))
)

mse_table |> print()


#------------------------------------------------------------
library(xtable)
df <- mse_table
df[, sapply(df, is.numeric)] <- lapply(df[, sapply(df, is.numeric)], formatC, format = "e", digits = 2)
print(xtable(df, scientific = TRUE), type = "latex")

#------------------------------------------------------------

freq <- seq(0, pi, 0.001)
omega <- freq/2/pi

filters <- get_middle_point_filters(y1+y2, L, alpha = 0)
filt <- filters[[1]] + filters[[2]]

# print(afc(filt, freq), digits = 1)

plot(afc(filt, freq) ~ omega, type = "l")
abline(v = 1/12, col = "red")


# abline(v = 1/12 + 4.3/(12*12))
abline(v = 1/18)

filters <- get_middle_point_filters(y1+y2, L, alpha = alpha)
filt <- filters[[1]] + filters[[2]]

lines(afc(filt, freq) ~ omega, col ="blue")


library(ggplot2)

alphas <- c(0, 1/2)
freq <- seq(0, pi, 0.001)
omega <- freq / (2 * pi)

# Определяем цвета (черный для 0, остальные разные)
colors <- c("black", "blue")

# Создаем пустой график
plot(NULL, xlim = c(0, 0.2), ylim = c(0, 1), xlab = "Частота", 
     ylab = "АЧХ", main = "АЧХ для суммы фильтров собственных троек синуса"
     , xaxt = "n"
     )

alpha <- alphas[1]
filters <- get_middle_point_filters(y, L, alpha = alpha)
filt <- filters[[1]] + filters[[2]]

lines(omega, afc(filt, freq), col = colors[1], lwd = 2)

# Рисуем графики для каждого alpha
for (i in seq_along(alphas)) {
  alpha <- alphas[i]
  filters <- get_middle_point_filters(y, L, alpha = alpha)
  filt <- filters[[1]] + filters[[2]]
  
  lines(omega, afc(filt, freq), col = colors[i], lwd = 2)
}

# Добавляем вертикальную линию
abline(v = 1/12, col = "red", lty = 2)
# Добавляем подпись на оси X
axis(1, at = 1/12, labels = "1/12")

# Добавляем легенду с LaTeX-обозначением α
legend("topright", legend = sapply(alphas, function(a) bquote(alpha == .(a))),
       col = colors, lwd = 2)

abline(v = 1/19, col = "red", lty = 2)
axis(1, at = 1/19, labels = "1/19")
axis(1, at = c(0, 0.1, 0.15, 0.2), labels = c("0", "0.1", "0.15", "0.2"))
```

#### Ошибка только для средних точек

```{r}
n <- 96*2-1
x <- 0:(n-1)
L <- 48
w1 <- 1/19
y1 <- sin(2*pi/12 * x)
y2 <- cos(2*pi*w1 * x)/2
y <- y1 + y2
alpha <- 1/2
filt <- sqrt(sin(pi * 1:(L) / (L + 1))^2)^alpha

  
s <- ssa(y, L)
r <- reconstruct(s, groups = list(
  s1 = 1:2,
  s2 = 3:4
))

sw <- ssa(y, L, col.oblique = filt, row.oblique = rep(1, n-L+1))
rw <- reconstruct(sw, groups = list(
  s1 = 1:2,
  s2 = 3:4
))

mse <- function(f_true, f_reconstructed){
   mean((f_true - f_reconstructed)^2) 
}


r_gssa <- gssa(y, L, alpha = alpha)

# mse(rw$e, r_gssa$ts[[1]])
# mse(r$s1, y1)
# mse(rw$s1, y1)
# mse(r_gssa$ts[[1]] + r_gssa$ts[[2]], y1)


# Create a data frame to store MSE values
mse_table <- data.frame(
  Method = c("SSA", "rw", "GSSA"),
  MSE_y1 = c(mse(r$s1[L:(n - L + 1)], y1[L:(n - L + 1)]),
             mse(rw$s1[L:(n - L + 1)], y1[L:(n - L + 1)]),
             mse(r_gssa$ts[[1]][L:(n - L + 1)] + r_gssa$ts[[2]][L:(n - L + 1)], y1[L:(n - L + 1)])),
  MSE_y2 = c(mse(r$s2[L:(n - L + 1)], y2[L:(n - L + 1)]),
             mse(rw$s2[L:(n - L + 1)], y2[L:(n - L + 1)]),
             mse(r_gssa$ts[[3]][L:(n - L + 1)] + r_gssa$ts[[4]][L:(n - L + 1)], y2[L:(n - L + 1)])),
  MSE_y = c(mse(r$s1[L:(n - L + 1)] + r$s2[L:(n - L + 1)], y1[L:(n - L + 1)] + y2[L:(n - L + 1)]),
                     mse(rw$s1[L:(n - L + 1)] + rw$s2[L:(n - L + 1)], y1[L:(n - L + 1)] + y2[L:(n - L + 1)]),
                     mse(r_gssa$ts[[1]][L:(n - L + 1)] +
                           r_gssa$ts[[2]][L:(n - L + 1)] +
                           r_gssa$ts[[3]][L:(n - L + 1)] +
                           r_gssa$ts[[4]][L:(n - L + 1)], y1[L:(n - L + 1)] + y2[L:(n - L + 1)]))
)

mse_table |> print()


#------------------------------------------------------------
library(xtable)
df <- mse_table
df[, sapply(df, is.numeric)] <- lapply(df[, sapply(df, is.numeric)], formatC, format = "e", digits = 2)
print(xtable(df, scientific = TRUE), type = "latex")

#------------------------------------------------------------

freq <- seq(0, pi, 0.001)
omega <- freq/2/pi

filters <- get_middle_point_filters(y1+y2, L, alpha = 0)
filt <- filters[[1]] + filters[[2]]

# print(afc(filt, freq), digits = 1)

plot(afc(filt, freq) ~ omega, type = "l")
abline(v = 1/12, col = "red")


# abline(v = 1/12 + 4.3/(12*12))
abline(v = 1/18)

filters <- get_middle_point_filters(y1+y2, L, alpha = alpha)
filt <- filters[[1]] + filters[[2]]

lines(afc(filt, freq) ~ omega, col ="blue")


library(ggplot2)

alphas <- c(0, 1/2)
freq <- seq(0, pi, 0.001)
omega <- freq / (2 * pi)

# Определяем цвета (черный для 0, остальные разные)
colors <- c("black", "blue")

# Создаем пустой график
plot(NULL, xlim = c(0, 0.2), ylim = c(0, 1), xlab = "Частота", 
     ylab = "АЧХ", main = "АЧХ для суммы фильтров собственных троек синуса"
     , xaxt = "n"
     )

alpha <- alphas[1]
filters <- get_middle_point_filters(y, L, alpha = alpha)
filt <- filters[[1]] + filters[[2]]

lines(omega, afc(filt, freq), col = colors[1], lwd = 2)

# Рисуем графики для каждого alpha
for (i in seq_along(alphas)) {
  alpha <- alphas[i]
  filters <- get_middle_point_filters(y, L, alpha = alpha)
  filt <- filters[[1]] + filters[[2]]
  
  lines(omega, afc(filt, freq), col = colors[i], lwd = 2)
}

# Добавляем вертикальную линию
abline(v = 1/12, col = "red", lty = 2)
# Добавляем подпись на оси X
axis(1, at = 1/12, labels = "1/12")

# Добавляем легенду с LaTeX-обозначением α
legend("topright", legend = sapply(alphas, function(a) bquote(alpha == .(a))),
       col = colors, lwd = 2)

abline(v = 1/19, col = "red", lty = 2)
axis(1, at = 1/19, labels = "1/19")
axis(1, at = c(0, 0.1, 0.15, 0.2), labels = c("0", "0.1", "0.15", "0.2"))
```

#### sin + cos + плохое L

```{r}
# n <- 96*2-1
n <- 48*2-1
x <- 0:(n-1)
L <- 25
y1 <- sin(2*pi/12 * x)
y2 <- cos(2*pi/3 * x)/2
y <- y1 + y2
alpha <- 1/2
filt <- sqrt(sin(pi * 1:(L) / (L + 1))^2)^alpha

  
s <- ssa(y, L)
r <- reconstruct(s, groups = list(
  s1 = 1:2,
  s2 = 3:4
))

sw <- ssa(y, L, col.oblique = filt, row.oblique = rep(1, n-L+1))
rw <- reconstruct(sw, groups = list(
  s1 = 1:2,
  s2 = 3:4
))

mse <- function(f_true, f_reconstructed){
   mean((f_true - f_reconstructed)^2) 
}


r_gssa <- gssa(y, L, alpha = alpha)

# mse(rw$e, r_gssa$ts[[1]])
# mse(r$s1, y1)
# mse(rw$s1, y1)
# mse(r_gssa$ts[[1]] + r_gssa$ts[[2]], y1)


# Create a data frame to store MSE values
mse_table <- data.frame(
  Method = c("r", "rw", "r_gssa"),
  MSE_y1 = c(mse(r$s1, y1),
             mse(rw$s1, y1),
             mse(r_gssa$ts[[1]] + r_gssa$ts[[2]], y1)),
  MSE_y2 = c(mse(r$s2, y2),
             mse(rw$s2, y2),
             mse(r_gssa$ts[[3]] + r_gssa$ts[[4]], y2)),
  MSE_y = c(mse(r$s1 + r$s2, y1 + y2),
                     mse(rw$s1 + rw$s2, y1 + y2),
                     mse(r_gssa$ts[[1]] +
                           r_gssa$ts[[2]] +
                           r_gssa$ts[[3]] +
                           r_gssa$ts[[4]], y1 + y2))
)

mse_table
```

Получилось лучше

#### ! sin + cos + шум + хорошее L

```{r}
# Load necessary library
n <- 96*2-1
x <- 0:(n-1)
L <- 48
y1 <- sin(2*pi/12 * x)
y2 <- cos(2*pi/19 * x)/2
y <- y1 + y2
alpha <- 1
filt <- sqrt(sin(pi * 1:(L) / (L + 1))^2)^alpha

# Define parameters
n_experiment <- 100
sigma <- 0.1

# Initialize vectors to store MSE values
mse_r_y1 <- numeric(n_experiment)
mse_rw_y1 <- numeric(n_experiment)
mse_rgssa_y1 <- numeric(n_experiment)
mse_r_y2 <- numeric(n_experiment)
mse_rw_y2 <- numeric(n_experiment)
mse_rgssa_y2 <- numeric(n_experiment)
mse_r_y <- numeric(n_experiment)
mse_rw_y <- numeric(n_experiment)
mse_rgssa_y <- numeric(n_experiment)

# Set seed for reproducibility
set.seed(123)

# Perform experiments
for (i in 1:n_experiment) {
  # Add noise to y
  noisy_y <- y + rnorm(n, mean = 0, sd = sigma)
  
  # Perform SSA
  s <- ssa(noisy_y, L)
  r <- reconstruct(s, groups = list(s1 = 1:2, s2 = 3:4))
  
  # Perform SSA with oblique filtering
  sw <- ssa(noisy_y, L, col.oblique = filt, row.oblique = rep(1, n - L + 1))
  rw <- reconstruct(sw, groups = list(s1 = 1:2, s2 = 3:4))
  
  # Perform gSSA
  r_gssa <- gssa(noisy_y, L, alpha = alpha)
  
  # Calculate MSE for r method
  mse_r_y1[i] <- mse(r$s1, y1)
  mse_r_y2[i] <- mse(r$s2, y2)
  mse_r_y[i] <- mse(r$s1 + r$s2, y1 + y2)
  
  # Calculate MSE for rw method
  mse_rw_y1[i] <- mse(rw$s1, y1)
  mse_rw_y2[i] <- mse(rw$s2, y2)
  mse_rw_y[i] <- mse(rw$s1 + rw$s2, y1 + y2)
  
  # Calculate MSE for r_gssa method
  mse_rgssa_y1[i] <- mse(r_gssa$ts[[1]] + r_gssa$ts[[2]], y1)
  mse_rgssa_y2[i] <- mse(r_gssa$ts[[3]] + r_gssa$ts[[4]], y2)
  mse_rgssa_y[i] <- mse(r_gssa$ts[[1]] + r_gssa$ts[[2]] + r_gssa$ts[[3]] + r_gssa$ts[[4]], y1 + y2)
}

# Compute mean and standard deviation of MSE values
mean_mse_r_y1 <- mean(mse_r_y1)
sd_mse_r_y1 <- sd(mse_r_y1)

mean_mse_rw_y1 <- mean(mse_rw_y1)
sd_mse_rw_y1 <- sd(mse_rw_y1)

mean_mse_rgssa_y1 <- mean(mse_rgssa_y1)
sd_mse_rgssa_y1 <- sd(mse_rgssa_y1)

mean_mse_r_y2 <- mean(mse_r_y2)
sd_mse_r_y2 <- sd(mse_r_y2)

mean_mse_rw_y2 <- mean(mse_rw_y2)
sd_mse_rw_y2 <- sd(mse_rw_y2)

mean_mse_rgssa_y2 <- mean(mse_rgssa_y2)
sd_mse_rgssa_y2 <- sd(mse_rgssa_y2)

mean_mse_r_y <- mean(mse_r_y)
sd_mse_r_y <- sd(mse_r_y)

mean_mse_rw_y <- mean(mse_rw_y)
sd_mse_rw_y <- sd(mse_rw_y)

mean_mse_rgssa_y <- mean(mse_rgssa_y)
sd_mse_rgssa_y <- sd(mse_rgssa_y)

# Create a data frame with mean MSE values
mse_table <- data.frame(
  Method = c("r", "rw", "r_gssa"),
  MSE_y1 = c(mean_mse_r_y1, mean_mse_rw_y1, mean_mse_rgssa_y1),
  MSE_y2 = c(mean_mse_r_y2, mean_mse_rw_y2, mean_mse_rgssa_y2),
  MSE_y = c(mean_mse_r_y, mean_mse_rw_y, mean_mse_rgssa_y)
)

# Optionally, include standard deviations
mse_table$SD_y1 <- c(sd_mse_r_y1, sd_mse_rw_y1, sd_mse_rgssa_y1)
mse_table$SD_y2 <- c(sd_mse_r_y2, sd_mse_rw_y2, sd_mse_rgssa_y2)
mse_table$SD_y <- c(sd_mse_r_y, sd_mse_rw_y, sd_mse_rgssa_y)

# Print the table
print(mse_table)

library(xtable)
df <- mse_table
df[, sapply(df, is.numeric)] <- lapply(df[, sapply(df, is.numeric)], formatC, format = "e", digits = 2)
print(xtable(df, scientific = TRUE), type = "latex")

```

Проверка значимости:

```{r}
x <- mse_r_y1
y <- mse_rgssa_y1
t_test_result <- t.test(x, y, paired = TRUE)
print(paste("sin, ", "SSA", " ", "GSSA", ", p-val = ", t_test_result$p.value))

x <- mse_r_y2
y <- mse_rgssa_y2
t_test_result <- t.test(x, y, paired = TRUE)
print(paste("sin, ", "SSA", " ", "GSSA", ", p-val = ", t_test_result$p.value))

x <- mse_r_y
y <- mse_rgssa_y
t_test_result <- t.test(x, y, paired = TRUE)
print(paste("sin, ", "SSA", " ", "GSSA", ", p-val = ", t_test_result$p.value))
```

#### sin + cos + шум + плохое L

```{r}
# Load necessary library
n <- 96*2-1
x <- 0:(n-1)
L <- 50
y1 <- sin(2*pi/12 * x)
y2 <- cos(2*pi/19 * x)/2
y <- y1 + y2
alpha <- 1
filt <- sqrt(sin(pi * 1:(L) / (L + 1))^2)^alpha

# Define parameters
n_experiment <- 100
sigma <- 0.1

# Initialize vectors to store MSE values
mse_r_y1 <- numeric(n_experiment)
mse_rw_y1 <- numeric(n_experiment)
mse_rgssa_y1 <- numeric(n_experiment)
mse_r_y2 <- numeric(n_experiment)
mse_rw_y2 <- numeric(n_experiment)
mse_rgssa_y2 <- numeric(n_experiment)
mse_r_y <- numeric(n_experiment)
mse_rw_y <- numeric(n_experiment)
mse_rgssa_y <- numeric(n_experiment)

# Set seed for reproducibility
set.seed(123)

# Perform experiments
for (i in 1:n_experiment) {
  # Add noise to y
  noisy_y <- y + rnorm(n, mean = 0, sd = sigma)
  
  # Perform SSA
  s <- ssa(noisy_y, L)
  r <- reconstruct(s, groups = list(s1 = 1:2, s2 = 3:4))
  
  # Perform SSA with oblique filtering
  sw <- ssa(noisy_y, L, col.oblique = filt, row.oblique = rep(1, n - L + 1))
  rw <- reconstruct(sw, groups = list(s1 = 1:2, s2 = 3:4))
  
  # Perform gSSA
  r_gssa <- gssa(noisy_y, L, alpha = alpha)
  
  # Calculate MSE for r method
  mse_r_y1[i] <- mse(r$s1, y1)
  mse_r_y2[i] <- mse(r$s2, y2)
  mse_r_y[i] <- mse(r$s1 + r$s2, y1 + y2)
  
  # Calculate MSE for rw method
  mse_rw_y1[i] <- mse(rw$s1, y1)
  mse_rw_y2[i] <- mse(rw$s2, y2)
  mse_rw_y[i] <- mse(rw$s1 + rw$s2, y1 + y2)
  
  # Calculate MSE for r_gssa method
  mse_rgssa_y1[i] <- mse(r_gssa$ts[[1]] + r_gssa$ts[[2]], y1)
  mse_rgssa_y2[i] <- mse(r_gssa$ts[[3]] + r_gssa$ts[[4]], y2)
  mse_rgssa_y[i] <- mse(r_gssa$ts[[1]] + r_gssa$ts[[2]] + r_gssa$ts[[3]] + r_gssa$ts[[4]], y1 + y2)
}

# Compute mean and standard deviation of MSE values
mean_mse_r_y1 <- mean(mse_r_y1)
sd_mse_r_y1 <- sd(mse_r_y1)

mean_mse_rw_y1 <- mean(mse_rw_y1)
sd_mse_rw_y1 <- sd(mse_rw_y1)

mean_mse_rgssa_y1 <- mean(mse_rgssa_y1)
sd_mse_rgssa_y1 <- sd(mse_rgssa_y1)

mean_mse_r_y2 <- mean(mse_r_y2)
sd_mse_r_y2 <- sd(mse_r_y2)

mean_mse_rw_y2 <- mean(mse_rw_y2)
sd_mse_rw_y2 <- sd(mse_rw_y2)

mean_mse_rgssa_y2 <- mean(mse_rgssa_y2)
sd_mse_rgssa_y2 <- sd(mse_rgssa_y2)

mean_mse_r_y <- mean(mse_r_y)
sd_mse_r_y <- sd(mse_r_y)

mean_mse_rw_y <- mean(mse_rw_y)
sd_mse_rw_y <- sd(mse_rw_y)

mean_mse_rgssa_y <- mean(mse_rgssa_y)
sd_mse_rgssa_y <- sd(mse_rgssa_y)

# Create a data frame with mean MSE values
mse_table <- data.frame(
  Method = c("r", "rw", "r_gssa"),
  MSE_y1 = c(mean_mse_r_y1, mean_mse_rw_y1, mean_mse_rgssa_y1),
  MSE_y2 = c(mean_mse_r_y2, mean_mse_rw_y2, mean_mse_rgssa_y2),
  MSE_y = c(mean_mse_r_y, mean_mse_rw_y, mean_mse_rgssa_y)
)

# Optionally, include standard deviations
mse_table$SD_y1 <- c(sd_mse_r_y1, sd_mse_rw_y1, sd_mse_rgssa_y1)
mse_table$SD_y2 <- c(sd_mse_r_y2, sd_mse_rw_y2, sd_mse_rgssa_y2)
mse_table$SD_y <- c(sd_mse_r_y, sd_mse_rw_y, sd_mse_rgssa_y)

# Print the table
print(mse_table)
```

#### sin + шум с разными L

```{r}

# Load necessary library
n <- 96*2-1
x <- 0:(n-1)
L <- 50
y1 <- sin(2*pi/12 * x)
y2 <- cos(2*pi/3 * x)/2
y <- y1 + y2
alpha <- 1/2
filt <- sqrt(sin(pi * 1:(L) / (L + 1))^2)^alpha


# Define parameters
n_experiment <- 100
sigma <- 0.000001

# Initialize vectors to store MSE values
mse_r_y1 <- numeric(n_experiment)
mse_rw_y1 <- numeric(n_experiment)
mse_rgssa_y1 <- numeric(n_experiment)

# Set seed for reproducibility
set.seed(123)

# Perform experiments
for (i in 1:n_experiment) {
  # Add noise to y1
  noisy_y <- y1 + rnorm(n, mean = 0, sd = sigma)
  
  # Perform SSA
  s <- ssa(noisy_y, L)
  r <- reconstruct(s, groups = list(s1 = 1:2))
  
  # Perform SSA with oblique filtering
  sw <- ssa(noisy_y, L, col.oblique = filt, row.oblique = rep(1, n - L + 1))
  rw <- reconstruct(sw, groups = list(s1 = 1:2))
  
  # Perform gSSA
  r_gssa <- gssa(noisy_y, L, alpha = alpha)
  
  # Calculate MSE for r method
  mse_r_y1[i] <- mse(r$s1, y1)
  
  # Calculate MSE for rw method
  mse_rw_y1[i] <- mse(rw$s1, y1)
  
  # Calculate MSE for r_gssa method
  mse_rgssa_y1[i] <- mse(r_gssa$ts[[1]] + r_gssa$ts[[2]], y1)
}

# Compute mean and standard deviation of MSE values
mean_mse_r_y1 <- mean(mse_r_y1)
sd_mse_r_y1 <- sd(mse_r_y1)

mean_mse_rw_y1 <- mean(mse_rw_y1)
sd_mse_rw_y1 <- sd(mse_rw_y1)

mean_mse_rgssa_y1 <- mean(mse_rgssa_y1)
sd_mse_rgssa_y1 <- sd(mse_rgssa_y1)

# Create a data frame with mean MSE values for y1
mse_table <- data.frame(
  Method = c("r", "rw", "r_gssa"),
  MSE_y1 = c(mean_mse_r_y1, mean_mse_rw_y1, mean_mse_rgssa_y1),
  SD_y1 = c(sd_mse_r_y1, sd_mse_rw_y1, sd_mse_rgssa_y1)
)

# Print the table
print(mse_table)
```

### sin + cos + шум SSA потом GSSA

```{r}
n <- 96*2-1
x <- 0:(n-1)
L <- 48
y1 <- sin(2*pi/12 * x)
y2 <- cos(2*pi/19 * x)/2
y <- y1 + y2
alpha <- 1
filt <- sqrt(sin(pi * 1:(L) / (L + 1))^2)^alpha

# Define parameters
n_experiment <- 100
sigma <- 0.1

# Initialize vectors to store MSE values
mse_r_y1 <- numeric(n_experiment)
mse_rw_y1 <- numeric(n_experiment)
mse_rgssa_y1 <- numeric(n_experiment)
mse_r_y2 <- numeric(n_experiment)
mse_rw_y2 <- numeric(n_experiment)
mse_rgssa_y2 <- numeric(n_experiment)
mse_r_y <- numeric(n_experiment)
mse_rw_y <- numeric(n_experiment)
mse_rgssa_y <- numeric(n_experiment)

# Set seed for reproducibility
set.seed(123)

# Perform experiments
for (i in 1:n_experiment) {
  # Add noise to y
  noisy_y <- y + rnorm(n, mean = 0, sd = sigma)
  
  # Perform SSA
  s <- ssa(noisy_y, L)
  r <- reconstruct(s, groups = list(s1 = 1:2, s2 = 3:4))
  
  # Perform SSA with oblique filtering
  sw <- ssa(noisy_y, L, col.oblique = filt, row.oblique = rep(1, n - L + 1))
  rw <- reconstruct(sw, groups = list(s1 = 1:2, s2 = 3:4))
  
  # Perform gSSA
  r_gssa <- gssa(r$s1 + r$s2, L, alpha = alpha)
  
  # Calculate MSE for r method
  mse_r_y1[i] <- mse(r$s1, y1)
  mse_r_y2[i] <- mse(r$s2, y2)
  mse_r_y[i] <- mse(r$s1 + r$s2, y1 + y2)
  
  # Calculate MSE for rw method
  mse_rw_y1[i] <- mse(rw$s1, y1)
  mse_rw_y2[i] <- mse(rw$s2, y2)
  mse_rw_y[i] <- mse(rw$s1 + rw$s2, y1 + y2)
  
  # Calculate MSE for r_gssa method
  mse_rgssa_y1[i] <- mse(r_gssa$ts[[1]] + r_gssa$ts[[2]], y1)
  mse_rgssa_y2[i] <- mse(r_gssa$ts[[3]] + r_gssa$ts[[4]], y2)
  mse_rgssa_y[i] <- mse(r_gssa$ts[[1]] + r_gssa$ts[[2]] + r_gssa$ts[[3]] + r_gssa$ts[[4]], y1 + y2)
}

# Compute mean and standard deviation of MSE values
mean_mse_r_y1 <- mean(mse_r_y1)
sd_mse_r_y1 <- sd(mse_r_y1)

mean_mse_rw_y1 <- mean(mse_rw_y1)
sd_mse_rw_y1 <- sd(mse_rw_y1)

mean_mse_rgssa_y1 <- mean(mse_rgssa_y1)
sd_mse_rgssa_y1 <- sd(mse_rgssa_y1)

mean_mse_r_y2 <- mean(mse_r_y2)
sd_mse_r_y2 <- sd(mse_r_y2)

mean_mse_rw_y2 <- mean(mse_rw_y2)
sd_mse_rw_y2 <- sd(mse_rw_y2)

mean_mse_rgssa_y2 <- mean(mse_rgssa_y2)
sd_mse_rgssa_y2 <- sd(mse_rgssa_y2)

mean_mse_r_y <- mean(mse_r_y)
sd_mse_r_y <- sd(mse_r_y)

mean_mse_rw_y <- mean(mse_rw_y)
sd_mse_rw_y <- sd(mse_rw_y)

mean_mse_rgssa_y <- mean(mse_rgssa_y)
sd_mse_rgssa_y <- sd(mse_rgssa_y)

# Create a data frame with mean MSE values
mse_table <- data.frame(
  Method = c("r", "rw", "r_gssa"),
  MSE_y1 = c(mean_mse_r_y1, mean_mse_rw_y1, mean_mse_rgssa_y1),
  MSE_y2 = c(mean_mse_r_y2, mean_mse_rw_y2, mean_mse_rgssa_y2),
  MSE_y = c(mean_mse_r_y, mean_mse_rw_y, mean_mse_rgssa_y)
)

# Optionally, include standard deviations
mse_table$SD_y1 <- c(sd_mse_r_y1, sd_mse_rw_y1, sd_mse_rgssa_y1)
mse_table$SD_y2 <- c(sd_mse_r_y2, sd_mse_rw_y2, sd_mse_rgssa_y2)
mse_table$SD_y <- c(sd_mse_r_y, sd_mse_rw_y, sd_mse_rgssa_y)

# Print the table
print(mse_table)

library(xtable)
df <- mse_table
df[, sapply(df, is.numeric)] <- lapply(df[, sapply(df, is.numeric)], formatC, format = "e", digits = 2)
print(xtable(df, scientific = TRUE), type = "latex")
```

### SSA/GSSA как фильтры

```{r}
get_middle_point_filters <- function(ts, L, alpha = 0){
  N <- length(ts)
  tmp <- 1:(L)
  w <- sqrt(sin(pi*tmp/(L+1))^2)^alpha
  X <- diag(w) %*% hankel(ts, L)
  K <- dim(X)[2] 
  X_t <- t(X)
  S <- X %*% X_t
  
  tmp <- eigen(S)
  lambda <- tmp$values
  lambda <- lambda[lambda > 0]
  d <- length(lambda)
  U <- tmp$vectors[, 1:d]
  
  weight <- sum(w)
  
  get_filter_i <- function(i){
    filt <- c()
    u <- U[, i]
    
    get_sum_j <- function(j){
      sm <- 0
      for ( k in 1:(L-abs(j)) ){
        sm <- sm + u[k]*u[k+abs(j)]*w[k]
      }
      sm / weight
    }
    
    lapply( (-(L-1)):(L-1), get_sum_j ) |> unlist()
  }
  
  lapply(1:d, get_filter_i)
  
  
}

```

```{r}
# ТЕСТ

get_point_filters_test <- function(ts, L, alpha = 0){
  N <- length(ts)
  tmp <- 1:(L)
  w <- sqrt(sin(pi*tmp/(L+1))^2)^alpha
  X <- diag(w) %*% hankel(ts, L)
  K <- dim(X)[2] 
  X_t <- t(X)
  S <- X %*% X_t
  
  tmp <- eigen(S)
  lambda <- tmp$values
  lambda <- lambda[lambda > 0]
  d <- length(lambda)
  U <- tmp$vectors[, 1:d]
  
  weight <- sum(w)
  
  get_filter_i <- function(i){
    filt <- c()
    u <- U[, i]
    
    W <- matrix(0, nrow = K, ncol = length(ts))
    W_w <- matrix(0, nrow = K, ncol = length(ts))
    for (i in 1:K){
      W[i, i:(i+L-1)] <- u * w
      W_w[i, i:(i+L-1)] <- u 
    }
    W_w <- t(W_w)
    
    D <- c()
    cm_sm <- 0
    for (i in 1:L){
      cm_sm <- cm_sm + w[i]
      D <- c(D, cm_sm)
    }
    for (i in (L+1):K){
      D<- c(D, cm_sm)
    }
    for (i in (K+1):length(ts)){
      cm_sm <- cm_sm - w[i-K]
      D <- c(D, cm_sm)
    }
    
    D <- diag(D)
    D <- solve(D)
    
    # print((D %*% W_w %*% W) %*% ts)
    
    (D %*% W_w %*% W) %*% ts
    # print(dim((D %*% W_w %*% W)))
    
  }
  lapply(1:d, get_filter_i)
}

n <- 96*2-1
x <- 0:(n-1)
L <- 48
y1 <- sin(2*pi/12 * x)
y2 <- cos(2*pi/3 * x)/2
y <- y1 + y2 
alpha <- 10


freq <- seq(0, pi, 0.001)
omega <- freq/2/pi

filters <- get_point_filters_test(y, L, alpha = alpha)
filt <- filters[[1]] + filters[[2]] 

r_gssa <- gssa(y, L, alpha = alpha)


(r_gssa$ts[[1]] + r_gssa$ts[[2]])  |> plot(type = "l")
# y2 |> lines()
filt |> lines(col = "red")
Reduce("+", filters)|> lines(col = "blue")
plot(y, type = "l")
Reduce("+", filters)|> lines(col = "blue")
```

## Функция фильтра для любой точки

```{r}
get_all_point_filters <- function(ts, L, alpha = 0){
  N <- length(ts)
  tmp <- 1:(L)
  w <- sqrt(sin(pi*tmp/(L+1))^2)^alpha
  X <- diag(w) %*% hankel(ts, L)
  K <- dim(X)[2] 
  X_t <- t(X)
  S <- X %*% X_t
  
  tmp <- eigen(S)
  lambda <- tmp$values
  lambda <- lambda[lambda > 0]
  d <- length(lambda)
  U <- tmp$vectors[, 1:d]
  
  weight <- sum(w)
  
  get_filter_i <- function(i){
    filt <- c()
    u <- U[, i]
    
    W <- matrix(0, nrow = K, ncol = length(ts))
    W_w <- matrix(0, nrow = K, ncol = length(ts))
    for (i in 1:K){
      W[i, i:(i+L-1)] <- u * w
      W_w[i, i:(i+L-1)] <- u 
    }
    W_w <- t(W_w)
    
    D <- c()
    cm_sm <- 0
    for (i in 1:L){
      cm_sm <- cm_sm + w[i]
      D <- c(D, cm_sm)
    }
    for (i in (L+1):K){
      D<- c(D, cm_sm)
    }
    for (i in (K+1):length(ts)){
      cm_sm <- cm_sm - w[i-K]
      D <- c(D, cm_sm)
    }
    
    D <- diag(D)
    D <- solve(D)
    
    # print((D %*% W_w %*% W) %*% ts)
    
    (D %*% W_w %*% W)
    
  }
  lapply(1:d, get_filter_i)
}


# n <- 96*2-1
# x <- 0:(n-1)
# L <- 48
# y1 <- sin(2*pi/12 * x)
# y <- y1
# 
# filts <- get_all_point_filters(y, L, alpha = 1/2)
# filt <- (filts[[1]]+filts[[2]])[1, ]
# 
# 
# 
# # filters <- get_middle_point_filters(y1, L, alpha = 0)
# # filt <- filters[[1]] + filters[[2]]
# #
# afс <- function(filt, freq) {
#   abs(fft(filt)) / length(filt)
# }
# plot(afс(filt, freq) ~ omega, type = "l")
# abline(v = 1/12, col = "red")

```

### Гифка

```{r}
library(ggplot2)
library(gganimate)
library(magick)

n <- 96*2-1
x <- 0:(n-1)
L <- 48
y1 <- sin(2*pi/12 * x)
y2 <- cos(2*pi/19 * x)/2
y <- y1 + y2


# # Функция для создания амплитудно-фазовой характеристики (АФЧ)
# afс <- function(filt, freq) {
#   abs(fft(filt)) / length(filt)
# }
afc <- function(filter, omega) {
  k <- seq_along(filter) - 1 #значения от 0 до length(filter) - 1
  h <- function(o) sum(rev(filter) * exp(-k*1i * o))
  abs(sapply(omega, h))
}

# Получаем фильтры
filts <- get_all_point_filters(y, L, alpha = 1/2)

filts_ssa <- get_all_point_filters(y, L, alpha = 0)

# Папка для сохранения кадров
dir.create("filter_frames", showWarnings = FALSE)


afc <- function(filter, omega) {
  k <- seq_along(filter) - 1 #значения от 0 до length(filter) - 1
  h <- function(o) sum(rev(filter) * exp(-k*1i * o))
  abs(sapply(omega, h))
}

# Создаем кадры для GIF
for (i in c(1, 10, 25, 50)) {
  filt <- (filts[[1]] + filts[[2]])[i, ]
  filt_ssa <- (filts_ssa[[1]] + filts_ssa[[2]])[i, ]
  omega <- seq(0, 1/2, length.out = length(filt))
  freq <- seq(0, pi, 0.01)
  omega <- freq/2/pi
  afc_values <- afc(filt, freq)
  afc_vals_ssa <-afc(filt_ssa, freq)
  
  
  # Создаем датафрейм для ggplot
  plot_data <- data.frame(
    omega = omega,
    afc_values = afc_values,
    afc_vals_ssa = afc_vals_ssa
  )
  
  # Основной график
  p <- ggplot(plot_data) +
    # Линии АЧХ
    geom_line(aes(x = omega, y = afc_values), color = "black", linewidth = 1) +
    geom_line(aes(x = omega, y = afc_vals_ssa), color = "blue", linewidth = 1) +
    
    # Вертикальные линии и подписи
    geom_vline(xintercept = 1/12, color = "red", linetype = "dashed") +
    geom_vline(xintercept = 1/19, color = "red", linetype = "dashed") +
    
    # Оси и заголовок
    labs(
      x = "Частота", 
      y = "АЧХ", 
      title = paste("АЧХ для точки", i)
    ) +
    
    # Настройка осей (как в вашем примере)
    scale_x_continuous(
      limits = c(0, 0.2),
      breaks = c(0, 1/19, 1/12, 0.1, 0.15, 0.2),
      labels = c("0", "1/19", "1/12", "0.1", "0.15", "0.2")
    ) +
    scale_y_continuous(limits = c(0, 1.1)) +
    
    theme_bw() 
    print(p)
  
}

```

### Хороший график

```{r}
library(ggplot2)

# Частоты
freq <- seq(0, pi, 0.001)
omega <- freq / (2 * pi)

# Список точек
points_to_plot <- c(1, 10, 20, 50)

# Собираем данные в датафрейм
plot_data_all <- do.call(rbind, lapply(points_to_plot, function(i) {
  filt <- (filts[[1]] + filts[[2]])[i, ]
  filt_ssa <- (filts_ssa[[1]] + filts_ssa[[2]])[i, ]
  
  data.frame(
    omega = omega,
    value = afc(filt, freq),
    method = "alpha = 1/2",
    point = paste0("Точка ", i)
  ) |> 
    rbind(data.frame(
      omega = omega,
      value = afc(filt_ssa, freq),
      method = "alpha = 0",
      point = paste0("Точка ", i)
    ))
}))

# Построение графика
p <- ggplot(plot_data_all, aes(x = omega, y = value, color = method)) +
   geom_line(size = 0.8) +  # <-- увеличение толщины линий
  geom_line() +
  facet_wrap(~ point, ncol = 2) +
  geom_vline(xintercept = c(1/12, 1/19), color = "red", linetype = "dashed") +
  scale_x_continuous(
    limits = c(0, 0.2),
    breaks = c(0, 1/19, 1/12, 0.1, 0.15, 0.2),
    labels = c("0", "1/19", "1/12", "0.1", "0.15", "0.2")
  ) +
   scale_color_manual(
    values = c("alpha = 1/2" = "black", "alpha = 0" = "blue")
  ) +
  scale_y_continuous(limits = c(0, 1.1)) +
  labs(x = "Частота", y = "АЧХ", title = "АЧХ для разных точек") +
  theme_bw() +
  theme(legend.position = "bottom")


# Сохранение с высоким разрешением
ggsave("afc_4_points.png", plot = p, 
       width = 10, height = 6, dpi = 300, 
       units = "in", bg = "white")
p

```

### График зависимости mse от времени

```{r}
# Load necessary library
library(Rssa)
library(xtable)

# Define parameters
n <- 96 * 2 - 1  # Длина временного ряда = 191
x <- 0:(n - 1)
L <- 48*2
y1 <- sin(2 * pi / 19 * x)
y2 <- cos(2 * pi / 12 * x) / 2
y <- y1 + y2
alpha <- 1
filt <- sqrt(sin(pi * 1:L / (L + 1))^2)^alpha

# Define parameters for experiments
n_experiment <- 100
sigma <- 0.1
n_t <- 96 * 2 - 1  # Ограничиваем до 100 временных индексов

# Set seed for reproducibility
set.seed(123)

# Initialize matrices to store squared errors for each t and each experiment
mse_r_y1_t <- matrix(0, nrow = n_t, ncol = n_experiment)
mse_rw_y1_t <- matrix(0, nrow = n_t, ncol = n_experiment)
mse_rgssa_y1_t <- matrix(0, nrow = n_t, ncol = n_experiment)
mse_r_y2_t <- matrix(0, nrow = n_t, ncol = n_experiment)
mse_rw_y2_t <- matrix(0, nrow = n_t, ncol = n_experiment)
mse_rgssa_y2_t <- matrix(0, nrow = n_t, ncol = n_experiment)
mse_r_y_t <- matrix(0, nrow = n_t, ncol = n_experiment)
mse_rw_y_t <- matrix(0, nrow = n_t, ncol = n_experiment)
mse_rgssa_y_t <- matrix(0, nrow = n_t, ncol = n_experiment)

# Perform experiments
for (i in 1:n_experiment) {
  # Add noise to y
  noisy_y <- y + rnorm(n, mean = 0, sd = sigma)
  
  # Perform SSA
  s <- ssa(noisy_y, L)
  r <- reconstruct(s, groups = list(s1 = 1:2, s2 = 3:4))
  
  # Perform SSA with oblique filtering
  sw <- ssa(noisy_y, L, col.oblique = filt, row.oblique = rep(1, n - L + 1))
  rw <- reconstruct(sw, groups = list(s1 = 1:2, s2 = 3:4))
  
  # Perform gSSA (предполагается, что gssa - это ваша функция)
  r_gssa <- gssa(noisy_y, L, alpha = alpha)
  
  # Calculate squared errors for each t (только первые 100 элементов)
  mse_r_y1_t[, i] <- (r$s1[1:n_t] - y1[1:n_t])^2
  mse_rw_y1_t[, i] <- (rw$s1[1:n_t] - y1[1:n_t])^2
  mse_rgssa_y1_t[, i] <- (r_gssa$ts[[1]][1:n_t] + r_gssa$ts[[2]][1:n_t] - y1[1:n_t])^2
  
  mse_r_y2_t[, i] <- (r$s2[1:n_t] - y2[1:n_t])^2
  mse_rw_y2_t[, i] <- (rw$s2[1:n_t] - y2[1:n_t])^2
  mse_rgssa_y2_t[, i] <- (r_gssa$ts[[3]][1:n_t] + r_gssa$ts[[4]][1:n_t] - y2[1:n_t])^2
  
  mse_r_y_t[, i] <- (r$s1[1:n_t] + r$s2[1:n_t] - y[1:n_t])^2
  mse_rw_y_t[, i] <- (rw$s1[1:n_t] + rw$s2[1:n_t] - y[1:n_t])^2
  mse_rgssa_y_t[, i] <- (r_gssa$ts[[1]][1:n_t] + r_gssa$ts[[2]][1:n_t] + 
                         r_gssa$ts[[3]][1:n_t] + r_gssa$ts[[4]][1:n_t] - y[1:n_t])^2
}

# Compute mean MSE for each t across experiments
mean_mse_r_y1_t <- rowMeans(mse_r_y1_t)
mean_mse_rw_y1_t <- rowMeans(mse_rw_y1_t)
mean_mse_rgssa_y1_t <- rowMeans(mse_rgssa_y1_t)

mean_mse_r_y2_t <- rowMeans(mse_r_y2_t)
mean_mse_rw_y2_t <- rowMeans(mse_rw_y2_t)
mean_mse_rgssa_y2_t <- rowMeans(mse_rgssa_y2_t)

mean_mse_r_y_t <- rowMeans(mse_r_y_t)
mean_mse_rw_y_t <- rowMeans(mse_rw_y_t)
mean_mse_rgssa_y_t <- rowMeans(mse_rgssa_y_t)
# 


# Подготовка данных для графика
plot_data_y1 <- data.frame(
  time = rep(1:n_t, 3),
  mse = c(mean_mse_r_y1_t, mean_mse_rw_y1_t, mean_mse_rgssa_y1_t),
  method = rep(c("r", "rw", "r_gssa"), each = n_t)
)

# Построение графика
p <- ggplot(plot_data_y1, aes(x = time, y = mse, color = method)) +
  geom_line(size = 0.8) +  # Увеличение толщины линий
  scale_color_manual(
    values = c("rw" = "black", "r_gssa" = "blue"),
    labels = c("r_gssa" = "alpha = 1/2", "rw" = "alpha = 0")
  ) +
  scale_x_continuous(
    breaks = seq(0, n_t, by = 20),
    labels = seq(0, n_t, by = 20)
  ) +
  scale_y_continuous(
    limits = range(c(mean_mse_r_y1_t, mean_mse_rw_y1_t, mean_mse_rgssa_y1_t)) * c(0.9, 1.1)
  ) +
  labs(
    x = "Время",
    y = "MSE",
    title = "Средний MSE по времени для синусоиды"
  ) +
  theme_bw() +
  theme(legend.position = "bottom")

# Сохранение графика с высоким разрешением
ggsave("mse_y1_time.png", plot = p, 
       width = 10, height = 6, dpi = 300, 
       units = "in", bg = "white")

# Вывод графика
print(p)
```

#### Проверка на совпадение middle filter и GSSA

```{r}
library(stats)


n <- 96*2-1
x <- 0:(n-1)
L <- 48
y1 <- sin(2*pi/12 * x)
y2 <- cos(2*pi/3 * x)/2
y <- y1 + y2 
alpha <- 10


freq <- seq(0, pi, 0.001)
omega <- freq/2/pi

filters <- get_middle_point_filters(y, L, alpha = alpha)
filt <- filters[[1]] + filters[[2]] 

r_gssa <- gssa(y, L, alpha = alpha)


(r_gssa$ts[[1]] + r_gssa$ts[[2]])  |> plot(type = "l")
# y2 |> lines()
filter(y, filter = filt, method = "convolution", sides = 2) |> lines(col = "red")
```

#### ! Сравнение ачх SSA и GSSA для одиночного sin

```{r}
n <- 96*2-1
x <- 0:(n-1)
L <- 48
y1 <- sin(2*pi/12 * x)
y <- y1

library(ggplot2)

alphas <- c(0, 1/2, 1, 2)
freq <- seq(0, pi, 0.001)
omega <- freq / (2 * pi)

# Определяем цвета (черный для 0, остальные разные)
colors <- c("black", "blue", "green", "purple", "orange")

# Создаем пустой график
plot(NULL, xlim = c(0, 0.2), ylim = c(0, 1), xlab = "Частота", 
     ylab = "АЧХ", main = "Фильтры для различных α")

alpha <- alphas[1]
filters <- get_middle_point_filters(y1, L, alpha = alpha)
filt <- filters[[1]] + filters[[2]]

lines(omega, afc(filt, freq), col = colors[1], lwd = 2)

# Рисуем графики для каждого alpha
for (i in seq_along(alphas)) {
  alpha <- alphas[i]
  filters <- get_middle_point_filters(y1, L, alpha = alpha)
  filt <- filters[[1]] + filters[[2]]
  
  lines(omega, afc(filt, freq), col = colors[i], lwd = 2)
}

# Добавляем вертикальную линию
abline(v = 1/12, col = "red", lty = 2)
# Добавляем подпись на оси X
axis(1, at = 1/12, labels = "1/12")

# Добавляем легенду с LaTeX-обозначением α
legend("topright", legend = sapply(alphas, function(a) bquote(alpha == .(a))),
       col = colors, lwd = 2)

abline(v = 2/50, col = "red", lty = 2)

```

#### sin попадающий в решетку

```{r}
n <- 96*2-1
x <- 0:(n-1)
L <- 48
y1 <- sin(2*pi/12 * x)
y2 <- cos(2*pi/3 * x)/2
y3 <- exp(x/100) + 1
y <- y1 + y2 + y3


freq <- seq(0, pi, 0.001)
omega <- freq/2/pi

filters <- get_middle_point_filters(y1, L, alpha = 0)
filt <- filters[[1]] + filters[[2]]

plot(afc(filt, freq) ~ omega, type = "l")
abline(v = 1/12, col = "red")
```

как видно, все остальные частоты, кроме частоты синуса, гасятся

#### sin не в решетке

```{r}
n <- 96*2
x <- 0:(n-1)
L <- 43
y1 <- sin(2*pi/12 * x)
y2 <- cos(2*pi/3 * x)/2
y3 <- exp(x/100) + 1
y <- y1 + y2 + y3

freq <- seq(0, pi, 0.001)
omega <- freq/2/pi

filters <- get_middle_point_filters(y1, L, alpha = 0)
filt <- filters[[1]] + filters[[2]]

plot(afc(filt, freq) ~ omega, type = "l")
abline(v = 1/12, col = "red")

filters <- get_middle_point_filters(y1, L, alpha = 1/2)
filt <- filters[[1]] + filters[[2]]

lines(afc(filt, freq) ~ omega, col ="blue")
```

АЧХ не сильно поменялся

#### exp + const

```{r}
n <- 96*2 -1
x <- 0:(n-1)
L <- 48
y1 <- sin(2*pi/12 * x)
y2 <- cos(2*pi/3 * x)/2
y3 <- exp(x/100) + 1
y <- y1 + y2 + y3


freq <- seq(0, pi, 0.001)
omega <- freq/2/pi

filters <- get_middle_point_filters(y3, L, alpha = 1/2)
filt <- filters[[1]] + filters[[2]]

plot(afc(filt, freq) ~ omega, type = "l")
```

Чем выше частота, тем сильнее она гасится

# --------

## FOSSA

```{r}
library(Rfssa)   
library(fda)     
library(Rssa)    

set.seed(123)    

N <-  50       
n <- 100       
s <- seq(0, 1, length.out = n)
omega <- 0.1   
sigma <- 0.0   



m_t <- function(t, s) {
  exp(s^2) * cos(2 * pi * omega * t) + cos(4 * pi * s) * sin(2 * pi * omega * t)
}



Y_list <- vector("list", N)
for (t in 1:N) {
  noise_t <- rnorm(n, mean = 0, sd = sigma)
  Y_list[[t]] <- m_t(t, s) + noise_t
}

Y_matrix <- do.call(cbind, Y_list)


# Создание объекта funts
nbasis <- 15
basis <- create.bspline.basis(rangeval = c(0, 1), nbasis = nbasis)



fts_obj <- funts(X = Y_matrix, 
                 basisobj = basis, 
                 argval = s, 
                 method = "data", 
                 start = 1, 
                 end = N)


L <- 10


res_fssa <- fssa(fts_obj, L = L, ntriples = 20, type = "ufssa")

plot(res_fssa, type = "values", d = 10, main = "Сингулярные значения FSSA")

plot(res_fssa, type = "vectors", d = 4, main = "Правые сингулярные векторы")

plot(res_fssa, type = "wcor", d = 10, main = "w-корреляция")


group_list <- list(
  1,       
  2:3,     
  4:5      
)

res_rec <- freconstruct(res_fssa, groups = group_list)

plot(res_rec[[1]], main = "Группа 1: Тренд")
plot(res_rec[[2]], main = "Группа 2: Сезонность")
plot(res_rec[[3]], main = "Группа 3: Остаточный шум")



```

#### FOSSA на m_t

```{r}
library(Rfssa)  
library(fda)    
library(Rssa)   



# Параметры моделирования
N <- 100        # число временных рядов 
grid_n <- 100  # (значения s)
s <- seq(0, 1, length.out = grid_n)
sigma <- (0.1)   # уровень шума (GWN)
omega <- 0.1   # значение ω 

# Функция для детерминированной части m_t(s)
m_t <- function(t, s, omega) {
  exp(s^2) * cos(2 * pi * omega * t) + cos(4 * pi * s) * sin(2 * pi * omega * t)
}



# Генерируем истинное значение функции без шума
true_matrix <- sapply(1:N, function(t) m_t(t, s, omega))
# true_matrix имеет размер grid_n x N (строки - значения s, столбцы - временные наблюдения)

# Генерируем зашумлённые данные: для каждого t от 1 до N добавляем белый шум
Y_list <- vector("list", N)
for (t in 1:N) {
  noise_t <- rnorm(grid_n, mean = 0, sd = sigma)
  Y_list[[t]] <- m_t(t, s, omega) + noise_t
}

# Объединяем список в матрицу наблюдений Y_matrix (размер grid_n x N)
Y_matrix <- do.call(cbind, Y_list)

# НАстоящий Y
Y_list <- vector("list", N)
for (t in 1:N) {
  Y_list[[t]] <- m_t(t, s, omega)
}

Y_true <- do.call(cbind, Y_list)

# Создаём объект funts с использованием B-сплайнов (nbasis = 15)
nbasis <- 15
basis <- create.bspline.basis(rangeval = c(0, 1), nbasis = nbasis)
fts_obj <- funts(X = Y_matrix,
                 basisobj = basis,
                 argval = s,
                 method = "data",
                 start = 1,
                 end = N)

# Функция для преобразования объекта funts в матрицу временных рядов
# (из funts извлекается произведение базисной матрицы и коэффициентов)
funts2mat <- function(funts_obj) {
  if (!inherits(funts_obj, "funts")) {
    stop("Input must be a funts object.")
  }
  nvar <- length(funts_obj$B_mat)
  result_list <- vector("list", nvar)
  for (i in seq_len(nvar)) {
    result_list[[i]] <- funts_obj$B_mat[[i]] %*% funts_obj$coefs[[i]]
  }
  if (nvar == 1) {
    return(result_list[[1]])
  } else {
    return(result_list)
  }
}

# Функция для реконструкции с помощью FSSA:
# Здесь мы используем fssa() и freconstruct(), а затем извлекаем матричное представление через funts2mat().
reconstruct_FSSA <- function(fts_obj, L) {
  res_fssa <- fssa(fts_obj, L = L)
  
  rec_obj <- freconstruct(res_fssa, groups = list(1:2))
  # plot(rec_obj[[1]])
  # plot(rec_obj[[1]])
  funts2mat(rec_obj[[1]])
}



L <- 30

# Получим реконструированную матрицу через FSSA
Y_recon <- reconstruct_FSSA(fts_obj, L)

# Вычислим RMSE между реконструкцией и истинным сигналом
RMSE_FSSA <- mean((Y_true - Y_recon)^2) |> sqrt()

cat("RMSE для FSSA относительно истинного сигнала:", RMSE_FSSA, "\n")

```

#### 2d-SSA на m_t

```{r}
library(Rssa)

# Преобразуем Y_matrix (grid_n x N) в формат изображения
# Применим 2D SSA
ssa_2d <- ssa(t(Y_matrix), kind = "2d-ssa", L = c(30, 50))  # размер окна можно настроить

# Реконструкция по первым 2 компонентам, аналогично FSSA
recon_2d <- reconstruct(ssa_2d, groups = list(1:8))

# plot(recon_2d)

Y_recon_2d <- recon_2d$F1

# Вычислим RMSE между реконструкцией 2D SSA и истинным сигнало
RMSE_2DSSA <- sqrt(mean((t(Y_true) - Y_recon_2d)^2))

cat("RMSE для 2D SSA относительно истинного сигнала:", RMSE_2DSSA, "\n")

```

#### MSSA на m_t

```{r}
library(Rssa)

# Преобразуем Y_matrix (grid_n x N) в формат изображения
# Применим 2D SSA
ssa_mssa <- ssa(t(Y_matrix), kind = "mssa", L = L)  # размер окна можно настроить

# Реконструкция по первым 2 компонентам, аналогично FSSA
recon_mssa <- reconstruct(ssa_mssa, groups = list(1:2))

Y_recon_mssa <- recon_mssa$F1

# plot(recon_2d)

# Вычислим RMSE между реконструкцией 2D SSA и истинным сигналом
RMSE_mssa <- sqrt(mean((t(Y_true) - Y_recon_mssa)^2))

cat("RMSE для MSSA относительно истинного сигнала:", RMSE_mssa, "\n")

```

### Таблица с FSSA, MSSA, 2d-SSA

```{r}
library(fda)    # для create.bspline.basis
library(Rssa)   # для fssa, ssa, freconstruct, reconstruct
library(dplyr)  # для группировки и summarize


set.seed(100)


run_ssa_benchmarks <- function(N_tests,
                               L_vals,
                               N_vals,
                               omega_vals,
                               sigma = 0.1,
                               grid_n = 100,
                               nbasis = 15) {
  # вспомогательная функция для одного прогона
  single_test <- function(N, L, omega) {
    s <- seq(0, 1, length.out = grid_n)
    
    # детермин. функция
    m_t <- function(t, s, omega) {
      exp(s^2) * cos(2 * pi * omega * t) +
        cos(4 * pi * s) * sin(2 * pi * omega * t)
    }
    
    # истина и шум
    true_mat <- sapply(1:N, function(t) m_t(t, s, omega))
    Y_mat   <- true_mat + matrix(rnorm(grid_n * N, 0, sigma),
                                 nrow = grid_n, ncol = N)
    
    # объект funts
    basis   <- create.bspline.basis(rangeval = c(0,1), nbasis = nbasis)
    fts_obj <- funts(X = Y_mat,
                     basisobj = basis,
                     argval   = s,
                     method   = "data",
                     start    = 1,
                     end      = N)
    
    # вспомог. для извлечения матрицы из funts
    funts2mat <- function(o) {
      B   <- o$B_mat[[1]]
      coefs <- o$coefs[[1]]
      B %*% coefs
    }
    
    # FSSA
    res_fssa <- fssa(fts_obj, L = L)
    rec_fssa <- freconstruct(res_fssa, groups = list(1:2))[[1]]
    Yf <- funts2mat(rec_fssa)
    rmse_fssa <- sqrt(mean((true_mat - Yf)^2))
    
    # 2D-SSA (на "изображении" t(Y_mat))
    ssa2 <- ssa(t(Y_mat), kind = "2d-ssa", L = c(L, 50))
    rec2 <- reconstruct(ssa2, groups = list(1:8))$F1
    rmse_2d  <- sqrt(mean((t(true_mat) - rec2)^2))
    
    # MSSA
    ssam <- ssa(t(Y_mat), kind = "mssa", L = L)
    recm <- reconstruct(ssam, groups = list(1:2))$F1
    rmse_mssa <- sqrt(mean((t(true_mat) - recm)^2))
    
    c(RMSE_FSSA = rmse_fssa,
      RMSE_2DSSA = rmse_2d,
      RMSE_MSSA  = rmse_mssa)
  }
  
  # создаём сетку параметров
  params <- expand.grid(L     = L_vals,
                        N     = N_vals,
                        omega = omega_vals,
                        KEEP.OUT.ATTRS = FALSE,
                        stringsAsFactors = FALSE)
  
  # для каждого набора параметров многократно запускаем single_test
  results <- params %>%
    rowwise() %>%
    do({
      comb <- .
      # матрица N_tests x 3
      rmse_mat <- replicate(N_tests,
                            single_test(comb$N, comb$L, comb$omega),
                            simplify = "matrix")
      # средние по каждому метода
      avg_rmse <- rowMeans(rmse_mat)
      data.frame(L        = comb$L,
                 N        = comb$N,
                 omega    = comb$omega,
                 RMSE_FSSA  = avg_rmse["RMSE_FSSA"],
                 RMSE_2DSSA = avg_rmse["RMSE_2DSSA"],
                 RMSE_MSSA  = avg_rmse["RMSE_MSSA"])
    }) %>%
    ungroup()
  
  return(results)
}

# Пример использования:
# пусть L_vals = c(20,30), N_vals = c(100,200), omega_vals = c(0.05,0.1)
# и N_tests = 10
benchmark_df <- run_ssa_benchmarks(
  N_tests   = 10,
  L_vals    = c(20, 30, 40),
  N_vals    = c(50, 100, 150, 200),
  omega_vals= c(0, 0.1, 0.25)
)

print(benchmark_df)

```

```{r}
library(dplyr)

generate_latex_table <- function(df) {
  # Sort the data frame by omega, N, and L
  df <- df %>% arrange(omega, N, L)
  
  # Print the table header
  cat("\\multicolumn{1}{c|}{$\\omega$} & \\multicolumn{1}{c|}{$N$} & \\multicolumn{3}{c|}{$L=20$} & \\multicolumn{3}{c|}{$L=30$} & \\multicolumn{3}{c}{$L=40$} \\\\\n")
  cat(" & & 2D-SSA & MSSA & FSSA & 2D-SSA & MSSA & FSSA & 2D-SSA & MSSA & FSSA \\\\\n")
  cat("\\midrule\n")
  
  # Get unique omega values
  unique_omega <- sort(unique(df$omega))
  
  # Loop over each omega
  for (k in 1:length(unique_omega)) {
    omega <- unique_omega[k]
    # Get unique N values for this omega
    unique_N <- sort(unique(df$N[df$omega == omega]))
    n_N <- length(unique_N)
    
    # Loop over each N
    for (i in 1:n_N) {
      N_val <- unique_N[i]
      # Filter and sort subset for this omega and N
      df_subset <- df %>% filter(omega == !!omega, N == !!N_val) %>% arrange(L)
      # Extract RMSE values in the desired order: 2DSSA, MSSA, FSSA
      rmse_matrix <- df_subset[, c("RMSE_2DSSA", "RMSE_MSSA", "RMSE_FSSA")]
      rmse_values <- as.vector(t(rmse_matrix))
      # Format RMSE values to three decimal places
      formatted_values <- sprintf("%.3f", rmse_values)
      
      if (i == 1) {
        # First row of omega block with multirow
        cat(paste0("\\multirow{", n_N, "}{*}{", sprintf("%.2f", omega), "} & ", N_val, " & ", paste(formatted_values, collapse = " & "), " \\\\\n"))
      } else {
        # Subsequent rows
        cat(paste0(" & ", N_val, " & ", paste(formatted_values, collapse = " & "), " \\\\\n"))
      }
    }
    
    # Add midrule or bottomrule
    if (k < length(unique_omega)) {
      cat("\\midrule\n")
    } else {
      cat("\\bottomrule\n")
    }
  }
}


# \begin{table}[h]
# \centering
# \begin{tabular}{c|cccccccccc}
# \toprule
# % Paste the output of generate_latex_table here
# \end{tabular}
# \caption{Результаты сравнения методов 2d-SSA, MSSA и FSSA при различных параметрах $\omega$ и $N$}
# \end{table}
generate_latex_table(benchmark_df)
```
