# Сравнение SSA, Fourier, CiSSA

```{r}

library(Rssa)



mse <- function(f_true, f_reconstructed){
   mean((f_true - f_reconstructed)^2) 
}


library(Rssa)
library(signal)
library(gsignal)




# CISSA
library(Rssa)
library(signal)
library(gsignal)


dftmtx <- function(n) {
  y <- stats::mvfft(diag(1, n))
  y
}

diag_averaging <- function(A){
  B <- A[nrow(A):1, ] |> Re()
  lapply(split(B, -(row(B) - col(B)) ), mean) |> as.numeric()
}

shift_vector <- function(vec) {
  last_element <- tail(vec, 1)
  vec <- vec[-length(vec)]
  shifted_vec <- c(last_element, vec)
  return(shifted_vec)
}

extend <- function(x, H){
  # Вычисление коэффициентов AR модели для дифференцированного ряда
  N <- length(x)
  p <- floor(N / 3)
  dx <- diff(x)
  # A <- ar(dx, order.max = p, method = "yule-walker")$ar
  A <- aryule(dx, p)$a
  
  # Правое расширение
  y <- x
  dy <- diff(y)
  er <- signal::filter(A, 1, dy)
  dy <- signal::filter(1, A, c(er, rep(0, H)))
  y <- y[1] + c(0, cumsum(dy))
  
  # Левое расширение
  y <- rev(y)
  dy <- diff(y)
  er <- signal::filter(A,1,dy)
  dy <- signal::filter(1,A,c(er, rep(0, H)))
  y <- y[1] + c(0, cumsum(dy))
  
  # Расширенный ряд
  xe <- rev(y)
  
  # Вывод результатов
  xe 
}


circulant_SSA <- function(ts, L = NULL, extend_flag = FALSE){
  time_series <- ts
  # Construct trajectory matrix
  N <- length(time_series)
  if (is.null(L)){
    L <- (N + 1)%/%2
  }
  # Проверка на расширения ряда
  if (extend_flag == FALSE){
    H <- 0
    time_series <- ts
  }
  else{
    H <- L
    time_series <- extend(ts, H)
  }
  
  X <- hankel(time_series, L)
  
  # Number of symmetric frequency pairs around 1/2
  if (L %% 2) {
    nf2 <- (L + 1) / 2 - 1
  } else {
    nf2 <- L / 2 - 1
  }
  
  # Number of frequencies <= 1/2
  nft <- nf2 + abs((L %% 2) - 2)
  
  # Decomposition
  # Estimate autocovariance     OK
  autocov <- numeric(L)
  for (m in 0:(L-1)){
    autocov[[m+1]] <- sum(time_series[1:(N-m)] * time_series[(1+m):N]) / (N-m)
  }
  
  # First row of circulant matrix
  circ_first_row <- numeric(L)
  for (m in 0:(L-1)){
    circ_first_row[[m+1]] <- (L-m)/L * autocov[[m+1]] + (m)/L * autocov[[L-m]]
  }
  
  # Build circulant matrix
  S_C <- matrix(circ_first_row, nrow = 1)
  shifted_vector <- circ_first_row
  for (i in 2:(L)) {
    shifted_vector <- shift_vector(shifted_vector)
    # S_C <- rbind(S_C, as.vector(shifted_vector))
    S_C <- rbind(as.vector(shifted_vector), S_C)
  }
  
  # Eigenvectors of circulant matrix (unitary base)
  U <- dftmtx(L)/sqrt(L)
  
  # Real eigenvectors (orthonormal base)
  U[, 1] <- Re(U[, 1])
  for (k in 1:nf2) {
    u_k <- U[, k + 1]
    U[, k + 1] <- sqrt(2) * Re(u_k)
    U[, L + 2 - (k + 1)] <- sqrt(2) * Im(u_k)
  }
  if (L %% 2 != 0) {
    U[, nft] <- Re(U[, nft])
  }
  
  # Eigenvalues of circulant matrix: estimated power spectral density
  psd <- abs(diag(t(U) %*% S_C %*% U))
  
  # Principal components
  W <- t(U) %*% X
  # Reconstruction
  # Elementary reconstructed series
  R <- matrix(0, nrow = N+2*H, ncol = L)
  for (k in 1:L) {
    R[, k] <- U[ ,k] %*% t(W[k, ]) |> diag_averaging()
  }
  
  # Grouping by frequency
  # Elementary reconstructed series by frequency
  Z <- matrix(0, nrow = N+2*H, ncol = nft)
  Z[, 1] <- R[, 1]
  # Importance of component
  imp <- numeric(nft)
  lambda_sm <- sum(psd)
  imp[1] <- psd[1]/lambda_sm
  for (k in 1:nf2) {
    Z[, k + 1] <- R[, k + 1] + R[, L + 2 - (k + 1)]
    imp[k+1] <- (psd[k+1] + psd[ L + 2 - (k + 1)])/lambda_sm
  }
  if (L %% 2 != 0) {
    Z[, nft] <- R[, nft]
    imp[nft] <- psd[nft] / lambda_sm
  }
  
  list(t_series = Z[(H+1):(N+H),],
       importance = imp,
       freq = (0:(length(imp) -1))/L
  )
}


# groups - list of frequencies
grouping_cissa <- function(cissa_res, groups){
  freq <- cissa_res$freq
  t_series <- cissa_res$t_series
  
  residuals <- 0
  result <- setNames(as.list(rep(0, length(groups))), names(groups))
  for (i in 1:length(cissa_res$freq)){
    flag <- FALSE
    for (name in names(groups)){
      if (groups[[name]][1] <= freq[i] & freq[i] <= groups[[name]][2]){
        flag <- TRUE
        result[[name]] <- result[[name]] + t_series[, i]
      }
    }
    
    if (flag == FALSE){
      residuals <- residuals + t_series[, i]
    }
  }
  
  result[["residuals"]] <- residuals
  result
}
```

```{r}
library(Rssa)
library(signal)
library(gsignal)
library(xtable)
source("eossa_new.R")
```

## Только sin + cos

### Цель

Показать, что CiSSA может выделять периодические компоненты лучше в том смысле, что нужны меньшие требования на параметры алгоритма.

### Дизайн эксперимента

**Постановка задачи**: знаем, какие частоты нужно выделять.

**Функция**: A1 sin(2 pi omega) + A2 cos(2 pi omega)

**Эксперименты:**

-   SSA, EOSSA\
    A1 == A2\
    A1 != A2

-   CiSSA, ext

-   Fourier, ext

```{r}

good_experiment <- function(
    L,
    n,
    x,
    t_series,
    groups_ssa,
    eossa_nested_groups,
    groups_freqs,
    table,
    y = NULL
  ){
  if (is.null(y)){
    y <- Reduce("+", t_series)
  }
  y_real <- Reduce("+", t_series)
    
  
  #----------------
  s_ssa <- ssa(y[1:(n-1)], L)
  r_ssa <- reconstruct(s_ssa, groups = groups_ssa)
  
  #---
  e_ssa <- eossa_new(s_ssa, nested.groups = eossa_nested_groups, clust_type = "distance")
  g_sesonal_e <- grouping.auto(e_ssa, base = "eigen",
                         freq.bins = groups_freqs,
                         threshold = 0.5)
  r_ssa_e <- reconstruct(e_ssa, groups=g_sesonal_e)
  
  #---
  r_fft <- reconstruct_fft(x, y)
  r_fft_grouped <- grouping_cissa(r_fft,
                      groups = groups_freqs
                      )$t_series
  
  #---
  r_fft_extended <- reconstruct_fft(x, y, TRUE)
  r_fft_grouped_extended <- grouping_cissa(r_fft_extended,
                      groups = groups_freqs
                      )$t_series
  
  #---
  r_cissa <- circulant_SSA(y, L)
  r_cissa_grouped <- grouping_cissa(r_cissa,
                      groups = groups_freqs
                      )$t_series
  
  # print(r_cissa)
  
  #---
  r_cissa_ext <- circulant_SSA(y, L, extend_flag = TRUE)
  r_cissa_grouped_ext <- grouping_cissa(r_cissa_ext,
                      groups = groups_freqs
                      )$t_series
  # print(r_cissa_grouped_ext)
  
  #---------------
  
  ssa_sum <- 0
  ssa_e_sum <- 0
  fft_sum <- 0
  fft_ext_sum <- 0
  cissa_sum <- 0
  cissa_ext_sum <- 0
  for (i in 1:length(t_series)){
    ts <- t_series[[i]]
    # print(table[1, i+1])
    
    table[1, i+1] <- mse(ts[1:(n-1)], r_ssa[[i]])
    ssa_sum <- ssa_sum + r_ssa[[i]]
    
    table[2, i+1] <- mse(ts[1:(n-1)], r_ssa_e[[i]])
    ssa_e_sum <- ssa_e_sum + r_ssa_e[[i]]
    
    table[3, i+1] <- mse(ts, r_fft_grouped[[i]])
    fft_sum <- fft_sum + r_fft_grouped[[i]]
    
    table[4, i+1] <- mse(ts, r_fft_grouped_extended[[i]])
    fft_ext_sum <- fft_ext_sum + r_fft_grouped_extended[[i]]
    
    table[5, i+1] <- mse(ts, r_cissa_grouped[[i]])
    cissa_sum <- cissa_sum + r_cissa_grouped[[i]]
    
    table[6, i+1] <- mse(ts, r_cissa_grouped_ext[[i]])
    cissa_ext_sum <- cissa_ext_sum + r_cissa_grouped_ext[[i]]
  }
  
  
  table[1, length(t_series)+2] <- mse(y_real[1:(n-1)], ssa_sum)
  
  table[2, length(t_series)+2] <- mse(y_real[1:(n-1)], ssa_e_sum)
  
  table[3, length(t_series)+2] <- mse(y_real, fft_sum)
  
  table[4, length(t_series)+2] <- mse(y_real, fft_ext_sum)
  
  table[5, length(t_series)+2] <- mse(y_real, cissa_sum)
  
  table[6, length(t_series)+2] <- mse(y_real, cissa_ext_sum)
  
  return(table)
}


df_to_latex_print <- function(df){
  # Функция для преобразования численных столбцов
  df[] <- lapply(df, function(x) {
    if (is.numeric(x)) {
      formatC(x, format = "e", digits = 1)
    } else {
      x
    }
  })
  
  table_latex <- xtable(df, caption = "Example Table")

  # Шаг 4: Вывод таблицы в LaTeX файл
  print(table_latex, include.rownames = FALSE)
}
```

#### 1 = A1 != A2 = 1/2

```{r}

n <- 96*2
L <- 96
x <- 0:(n-1)
y1 <- sin(2*pi/12 * x)
y2 <- cos(2*pi/3 * x)/2
y <- y1 + y2
X <- hankel(y, L = L)
eps <- 1/(n+1)

data <- data.frame(
  Метод = c("SSA, \nLw, Kw in N",
            "SSA EOSSA, \nLw, Kw in N",
            "Fourier, Nw in N",
            "Fourier extended, Nw in N",
            "CiSSA, Lw in N",
            "CiSSA extended, Lw in N"
            ),
  sin_err = c(1, 1, 1, 1, 1, 1),
  cos_err = c(1, 1, 1, 1, 1, 1),
  all_err = c(1, 1, 1, 1, 1, 1)
)

treshold <- (1/12 + 1/3)/2

df<- good_experiment(L, n, x,
                list(y1, y2),
                list(
                  F1 = c(1, 2),
                  F2 = c(3, 4)
                    ),
                list(1:4),
                list(
                      # sesonal_sin = c(1/12-eps, 1/12+eps),
                      sesonal_sin = c(0, 1/12+treshold - eps),
                      # sesonal_cos = c(1/3-eps, 1/3+eps)
                      sesonal_cos = c(1/3-treshold, 1/2)
                    ),
                data
) 

print(df)

df_to_latex_print(df)


```

#### A1 == A2 = 1

```{r}

n <- 96*2
L <- 96
x <- 0:(n-1)
y1 <- sin(2*pi/12 * x)
y2 <- cos(2*pi/3 * x)
y <- y1 + y2
X <- hankel(y, L = L)
eps <- 1/(n+1)

data <- data.frame(
  Метод = c("SSA, \nLw, Kw in N a1= a2",
            "SSA EOSSA, \nLw, Kw in N, a1 = a2",
            "Fourier, Nw in N",
            "Fourier extended, Nw in N",
            "CiSSA, Lw in N",
            "CiSSA extended, Lw in N"
            ),
  sin_err = c(1, 1, 1, 1, 1, 1),
  cos_err = c(1, 1, 1, 1, 1, 1),
  all_err = c(1, 1, 1, 1, 1, 1)
)


df <- good_experiment(L, n, x,
                list(y1, y2),
                list(
                  F1 = c(1, 2),
                  F2 = c(3, 4)
                    ),
                list(1:4),
                list(
                      # sesonal_sin = c(1/12-eps, 1/12+eps),
                      sesonal_sin = c(0, 1/12+treshold - eps),
                      # sesonal_cos = c(1/3-eps, 1/3+eps)
                      sesonal_cos = c(1/3-treshold, 1/2)
                    ),
                data
)
print(df)

df_to_latex_print(df)


```

#### N не подходит

```{r}
n <- 96*2-2
L <- 96
x <- 0:(n-1)
y1 <- sin(2*pi/12 * x)
y2 <- cos(2*pi/3 * x)
y <- y1 + y2
X <- hankel(y, L = L)
eps <- 1/(n+1)

data <- data.frame(
  Метод = c("SSA, \nLw, Kw not in N",
            "SSA EOSSA, \nLw, Kw not in N",
            "Fourier, Nw in N",
            "Fourier extended, Nw in N",
            "CiSSA, Lw in N",
            "CiSSA extended, Lw in N"
            ),
  sin_err = c(1, 1, 1, 1, 1, 1),
  cos_err = c(1, 1, 1, 1, 1, 1),
  all_err = c(1, 1, 1, 1, 1, 1)
)


df <- good_experiment(L, n, x,
                list(y1, y2),
                list(
                  F1 = c(3, 4),
                  F2 = c(1, 2)
                    ),
                list(1:4),
                list(
                      # sesonal_sin = c(1/12-eps, 1/12+eps),
                      sesonal_sin = c(0, 1/12+treshold - eps),
                      # sesonal_cos = c(1/3-eps, 1/3+eps)
                      sesonal_cos = c(1/3-treshold, 1/2)
                    ),
                data
)
print(df)

df_to_latex_print(df)
```

### Шум

```{r}
calculate_mean_across_tables <- function(tables_list) {
  # Проверяем, что все таблички имеют одинаковую структуру
  # if (length(unique(sapply(tables_list, dim))) != 1) {
  #   print(unique(sapply(tables_list, dim)))
  #   stop("Таблички имеют разную структуру")
  # }
  
  # Создаем пустой data.frame для результата
  result <- tables_list[[1]]
  
  # Проходим по каждому столбцу
  for (col in colnames(result)) {
    # Если столбец числовой, вычисляем среднее
    if (is.numeric(result[[col]])) {
      # Суммируем значения столбца по всем табличкам
      sum_col <- Reduce(`+`, lapply(tables_list, function(df) df[[col]]))
      # Делим на количество табличек, чтобы получить среднее
      result[[col]] <- sum_col / length(tables_list)
    }
    # Если столбец строковый, оставляем значение из первой таблички
    else if (is.character(result[[col]])) {
      result[[col]] <- tables_list[[1]][[col]]
    }
  }
  
  return(result)
}
```

1 = А1 != А2 = 1/2

```{r}
set.seed(50)

list_df <- list()

for (i in 1:10){
  n <- 96*2
  L <- 96
  x <- 0:(n-1)
  y1 <- sin(2*pi/12 * x)
  y2 <- cos(2*pi/3 * x)/2
  y <- y1 + y2 + rnorm(n, 0, 0.1)
  X <- hankel(y, L = L)
  eps <- 1/(n+1)
  
  data <- data.frame(
    Метод = c("SSA, \nLw, Kw in N",
              "SSA EOSSA, \nLw, Kw in N",
              "Fourier, Nw in N",
              "Fourier extended, Nw in N",
              "CiSSA, Lw in N",
              "CiSSA extended, Lw in N"
              ),
    sin_err = c(1, 1, 1, 1, 1, 1),
    cos_err = c(1, 1, 1, 1, 1, 1),
    all_err = c(1, 1, 1, 1, 1, 1)
  )
  
  treshold <- (1/12 + 1/3)/2
  
  df<- good_experiment(L, n, x,
                  list(y1, y2),
                  list(
                    F1 = c(1, 2),
                    F2 = c(3, 4)
                      ),
                  list(1:4),
                  list(
                        # sesonal_sin = c(1/12-eps, 1/12+eps),
                        sesonal_sin = c(1/12 - eps, 1/12 + eps),
                        # sesonal_cos = c(1/3-eps, 1/3+eps)
                        sesonal_cos = c(1/3-eps, 1/3+eps)
                      ),
                  data,
                  y
  ) 

  list_df[[i]] <- df
}

calculate_mean_across_tables(list_df) |> df_to_latex_print()

```

```{r}
set.seed(50)

list_df <- list()

for (i in 1:10){
  n <- 96*2
  L <- 96
  x <- 0:(n-1)
  y1 <- sin(2*pi/12 * x)
  y2 <- cos(2*pi/3 * x)
  y <- y1 + y2 + rnorm(n, 0, 0.1)
  X <- hankel(y, L = L)
  eps <- 1/(n+1)
  
  data <- data.frame(
    Метод = c("SSA, \nLw in N, Kw not in N",
              "SSA EOSSA, \nLw in N, Kw not in N",
              "Fourier, Nw not in N",
              "Fourier extended, Nw in N",
              "CiSSA, Lw in N",
              "CiSSA extended, Lw in N"
              ),
    sin_err = c(1, 1, 1, 1, 1, 1),
    cos_err = c(1, 1, 1, 1, 1, 1),
    all_err = c(1, 1, 1, 1, 1, 1)
  )
  
  treshold <- (1/12 + 1/3)/2
  
  df<- good_experiment(L, n, x,
                  list(y1, y2),
                  list(
                    F1 = c(3, 4),
                    F2 = c(1, 2)
                      ),
                  list(1:4),
                  list(
                        # sesonal_sin = c(1/12-eps, 1/12+eps),
                        sesonal_sin = c(1/12 - eps, 1/12 + eps),
                        # sesonal_cos = c(1/3-eps, 1/3+eps)
                        sesonal_cos = c(1/3-eps, 1/3+eps)
                      ),
                  data,
                  y
  ) 

  list_df[[i]] <- df
}

calculate_mean_across_tables(list_df) |> df_to_latex_print()
```

```{r}
set.seed(50)

list_df <- list()

for (i in 1:10){
  n <- 96*2-2
  L <- 96
  x <- 0:(n-1)
  y1 <- sin(2*pi/12 * x)
  y2 <- cos(2*pi/3 * x)
  y <- y1 + y2 + rnorm(n, 0, 0.1)
  X <- hankel(y, L = L)
  eps <- 1/(n+1)
  
  data <- data.frame(
    Метод = c("SSA, \nLw in N, Kw not in N, a1 = a2",
              "SSA EOSSA, \nLw in N, Kw not in N a1 = a2",
              "Fourier, Nw not in N",
              "Fourier extended, Nw in N",
              "CiSSA, Lw in N",
              "CiSSA extended, Lw in N"
              ),
    sin_err = c(1, 1, 1, 1, 1, 1),
    cos_err = c(1, 1, 1, 1, 1, 1),
    all_err = c(1, 1, 1, 1, 1, 1)
  )
  
  treshold <- (1/12 + 1/3)/2
  
  df<- good_experiment(L, n, x,
                  list(y1, y2),
                  list(
                    F1 = c(3, 4),
                    F2 = c(2, 1)
                      ),
                  list(1:4),
                  list(
                        # sesonal_sin = c(1/12-eps, 1/12+eps),
                        sesonal_sin = c(1/12 - eps, 1/12 + eps),
                        # sesonal_cos = c(1/3-eps, 1/3+eps)
                        sesonal_cos = c(1/3-eps, 1/3+eps)
                      ),
                  data,
                  y
  ) 

  list_df[[i]] <- df
}

calculate_mean_across_tables(list_df) |> df_to_latex_print()
```

## sin + exp\*cos

#### A1 != A2, хорошие условия

```{r}
n <- 96*2
L <- 96
x <- 0:(n-1)
y1 <- exp(x/200)*sin(2*pi/12 * x)
y2 <- exp(x/100)*cos(2*pi/3 * x)
y <- y1 + y2
X <- hankel(y, L = L)
eps <- 1/(n+1)
plot(y, type="l")

data <- data.frame(
  Метод = c("SSA, \nLw, Kw in N",
            "SSA EOSSA, \nLw, Kw in N",
            "Fourier, Nw in N",
            "Fourier extended, Nw in N",
            "CiSSA, Lw in N",
            "CiSSA extended, Lw in N"
            ),
  sin_err = c(1, 1, 1, 1, 1, 1),
  cos_err = c(1, 1, 1, 1, 1, 1),
  all_err = c(1, 1, 1, 1, 1, 1)
)

treshold <- (1/12 + 1/3)/2

df<- good_experiment(L, n, x,
                list(y1, y2),
                list(
                  F1 = c(3, 4),
                  F2 = c(1, 2)
                    ),
                list(1:4),
                list(
                      # sesonal_sin = c(1/12-eps, 1/12+eps),
                      sesonal_sin = c(0, 1/12+treshold - eps),
                      # sesonal_cos = c(1/3-eps, 1/3+eps)
                      sesonal_cos = c(1/3-treshold, 1/2)
                    ),
                data
) 

print(df)

df_to_latex_print(df)
```

#### A1 != A2, плохие

```{r}
n <- 96*2-2
L <- 48
x <- 0:(n-1)
y1 <- exp(x/200)*sin(2*pi/12 * x)
y2 <- exp(x/100)*cos(2*pi/3 * x)
y <- y1 + y2
X <- hankel(y, L = L)
eps <- 1/(n+1)
plot(y, type="l")

data <- data.frame(
  Метод = c("SSA, \nLw in N, Kw not in N",
            "SSA EOSSA, \nLw in N, Kw not in N",
            "Fourier, Nw in N",
            "Fourier extended, Nw in N",
            "CiSSA, Lw in N",
            "CiSSA extended, Lw in N"
            ),
  sin_err = c(1, 1, 1, 1, 1, 1),
  cos_err = c(1, 1, 1, 1, 1, 1),
  all_err = c(1, 1, 1, 1, 1, 1)
)

treshold <- (1/12 + 1/3)/2

df<- good_experiment(L, n, x,
                list(y1, y2),
                list(
                  F1 = c(3, 4),
                  F2 = c(1, 2)
                    ),
                list(1:4),
                list(
                      # sesonal_sin = c(1/12-eps, 1/12+eps),
                      sesonal_sin = c(0, 1/12+treshold - eps),
                      # sesonal_cos = c(1/3-eps, 1/3+eps)
                      sesonal_cos = c(1/3-treshold, 1/2)
                    ),
                data
) 

print(df)

df_to_latex_print(df)
```

#### A1 = A2, плохое

```{r}
n <- 96*2-2
L <- 96
x <- 0:(n-1)
y1 <- exp(x/200)*sin(2*pi/12 * x)
y2 <- exp(x/200)*cos(2*pi/3 * x)
y <- y1 + y2
X <- hankel(y, L = L)
eps <- 1/(n+1)
plot(y, type="l")

data <- data.frame(
  Метод = c("SSA, \nLw in N, Kw not in N",
            "SSA EOSSA, \nLw in N, Kw not in N",
            "Fourier, Nw in N",
            "Fourier extended, Nw in N",
            "CiSSA, Lw in N",
            "CiSSA extended, Lw in N"
            ),
  sin_err = c(1, 1, 1, 1, 1, 1),
  cos_err = c(1, 1, 1, 1, 1, 1),
  all_err = c(1, 1, 1, 1, 1, 1)
)

treshold <- (1/12 + 1/3)/2

df<- good_experiment(L, n, x,
                list(y1, y2),
                list(
                  F1 = c(3, 4),
                  F2 = c(1, 2)
                    ),
                list(1:4),
                list(
                      # sesonal_sin = c(1/12-eps, 1/12+eps),
                      sesonal_sin = c(0, 1/12+treshold - eps),
                      # sesonal_cos = c(1/3-eps, 1/3+eps)
                      sesonal_cos = c(1/3-treshold, 1/2)
                    ),
                data
) 

print(df)

df_to_latex_print(df)
```

### Шум

```{r}
set.seed(50)

list_df <- list()

for (i in 1:10){
   
  n <- 96*2
  L <- 96
  x <- 0:(n-1)
  y1 <- exp(x/200)*sin(2*pi/12 * x)
  y2 <- exp(x/100)*cos(2*pi/3 * x)
  y <- y1 + y2 + rnorm(n, 0, 0.1)
  X <- hankel(y, L = L)
  eps <- 1/(n+1)
  
  data <- data.frame(
    Метод = c("SSA, \nLw, Kw in N",
              "SSA EOSSA, \nLw, Kw in N",
              "Fourier, Nw in N",
              "Fourier extended, Nw in N",
              "CiSSA, Lw in N",
              "CiSSA extended, Lw in N"
              ),
    sin_err = c(1, 1, 1, 1, 1, 1),
    cos_err = c(1, 1, 1, 1, 1, 1),
    all_err = c(1, 1, 1, 1, 1, 1)
  )
  
  treshold <- (1/12 + 1/3)/2
  
  eps <- eps*4
  
  df<- good_experiment(L, n, x,
                  list(y1, y2),
                  list(
                    F1 = c(3, 4),
                    F2 = c(1, 2)
                      ),
                  list(1:4),
                  list(
                        # sesonal_sin = c(1/12-eps, 1/12+eps),
                        sesonal_sin = c(1/12 - 2*eps, 1/12 + 2*eps),
                        # sesonal_cos = c(1/3-eps, 1/3+eps)
                        sesonal_cos = c(1/3-3*eps, 1/3+3*eps)
                      ),
                  data,
                  y
  ) 

  list_df[[i]] <- df
}

calculate_mean_across_tables(list_df) |> df_to_latex_print()
```

```{r}
set.seed(50)

list_df <- list()

for (i in 1:10){
   
  n <- 96*2-2
  L <- 96
  x <- 0:(n-1)
  y1 <- exp(x/200)*sin(2*pi/12 * x)
  y2 <- exp(x/100)*cos(2*pi/3 * x)
  y <- y1 + y2 + rnorm(n, 0, 0.1)
  X <- hankel(y, L = L)
  eps <- 1/(n+1)
  
  data <- data.frame(
    Метод = c("SSA, \nLw, Kw in N",
              "SSA EOSSA, \nLw, Kw in N",
              "Fourier, Nw in N",
              "Fourier extended, Nw in N",
              "CiSSA, Lw in N",
              "CiSSA extended, Lw in N"
              ),
    sin_err = c(1, 1, 1, 1, 1, 1),
    cos_err = c(1, 1, 1, 1, 1, 1),
    all_err = c(1, 1, 1, 1, 1, 1)
  )
  
  treshold <- (1/12 + 1/3)/2
  eps <- eps*2
  
  df<- good_experiment(L, n, x,
                  list(y1, y2),
                  list(
                    F1 = c(3, 4),
                    F2 = c(1, 2)
                      ),
                  list(1:4),
                  list(
                        # sesonal_sin = c(1/12-eps, 1/12+eps),
                        sesonal_sin = c(1/12 - 2*eps, 1/12 + 2*eps),
                        # sesonal_cos = c(1/3-eps, 1/3+eps)
                        sesonal_cos = c(1/3-2*eps, 1/3+2*eps)
                      ),
                  data,
                  y
  ) 

  list_df[[i]] <- df
}

calculate_mean_across_tables(list_df) |> df_to_latex_print()
```

```{r}
set.seed(50)

list_df <- list()

for (i in 1:10){
   
  n <- 96*2-2
  L <- 96
  x <- 0:(n-1)
  y1 <- exp(x/200)*sin(2*pi/12 * x)
  y2 <- exp(x/200)*cos(2*pi/3 * x)
  y <- y1 + y2 + rnorm(n, 0, 0.1)
  X <- hankel(y, L = L)
  eps <- 1/(n+1)
  
  data <- data.frame(
    Метод = c("SSA, \nLw, Kw in N",
              "SSA EOSSA, \nLw, Kw in N",
              "Fourier, Nw in N",
              "Fourier extended, Nw in N",
              "CiSSA, Lw in N",
              "CiSSA extended, Lw in N"
              ),
    sin_err = c(1, 1, 1, 1, 1, 1),
    cos_err = c(1, 1, 1, 1, 1, 1),
    all_err = c(1, 1, 1, 1, 1, 1)
  )
  
  treshold <- (1/12 + 1/3)/2
  
  df<- good_experiment(L, n, x,
                  list(y1, y2),
                  list(
                    F1 = c(1, 2),
                    F2 = c(3, 4)
                      ),
                  list(1:4),
                  list(
                        # sesonal_sin = c(1/12-eps, 1/12+eps),
                        sesonal_sin = c(1/12 - eps, 1/12 + eps),
                        # sesonal_cos = c(1/3-eps, 1/3+eps)
                        sesonal_cos = c(1/3-eps, 1/3+eps)
                      ),
                  data,
                  y
  ) 

  list_df[[i]] <- df
}

calculate_mean_across_tables(list_df) |> df_to_latex_print()
```

## trend + sin + cos

### Цель

Показать, что с добавлением тренда выделение CiSSA и Фурье для периодик получаются хуже (то есть, что нужно изначально удалять тренд). При этом, расширение улучшает ситуацию.

Показать, что лучше выделять тренд с помощью SSA

### Дизайн эксперимента

**Постановка задачи**: знаем, какие частоты нужно выделять.

**Функция**: 1 + exp(x/100) + A1 sin(2 pi omega) + A2 cos(2 pi omega)

**Эксперименты:**

-   SSA, EOSSA\
    A1 == A2\
    A1 != A2

-   CiSSA, ext

-   Fourier, ext

```{r}
n <- 96*2
x <- 0:(n-1)
L <- 96
y1 <- sin(2*pi/12 * x)
y2 <- cos(2*pi/3 * x)/2
y3 <- exp(x/100) + 1
y <- y1 + y2 + y3
eps <- 1/(n+1)


data <- data.frame(
  Метод = c("SSA, \nLw, Kw in N",
            "SSA EOSSA, \nLw, Kw in N",
            "Fourier, Nw in N",
            "Fourier extended, Nw in N",
            "CiSSA, Lw in N",
            "CiSSA extended, Lw in N"
            ),
  exp_err = c(1, 1, 1, 1, 1, 1),
  sin_err = c(1, 1, 1, 1, 1, 1),
  cos_err = c(1, 1, 1, 1, 1, 1),
  all_err = c(1, 1, 1, 1, 1, 1)
)

df <- good_experiment(L, n, x,
                list(y3, y1, y2),
                list(
                  e = c(1, 6),
                  sesonal_sin = c(2, 3),
                  sesonal_cos = c(4, 5)
                    ),
                list(1:6),
                list(
                      trend = c(0, 1/12 - 2*eps),
                      # sesonal_sin = c(1/12-eps, 1/12+eps),
                      sesonal_sin = c(1/12-2*eps, 1/12+2*eps),
                      # sesonal_cos = c(1/3-eps, 1/3+eps)
                      sesonal_cos = c(1/3-2*eps, 1/2)
                    ),
                data
)
print(df)

df_to_latex_print(df)
```

```{r}
library(Rssa)
library(signal)
library(gsignal)

n <- 96*2
x <- 0:(n-1)
L <- 12
y1 <- sin(2*pi/12 * x)
y2 <- cos(2*pi/3 * x)
y3 <- exp(x/100) + 1
y <- y1 + y2 + y3
eps <- 1/(n+1)


data <- data.frame(
  Метод = c("SSA, \nLw, Kw in N, a1 = a2",
            "SSA EOSSA, \nLw, Kw in N, a1 = a2",
            "Fourier, Nw in N",
            "Fourier extended, Nw in N",
            "CiSSA, Lw in N",
            "CiSSA extended, Lw in N"
            ),
  exp_err = c(1, 1, 1, 1, 1, 1),
  sin_err = c(1, 1, 1, 1, 1, 1),
  cos_err = c(1, 1, 1, 1, 1, 1),
  all_err = c(1, 1, 1, 1, 1, 1)
)

df <- good_experiment(L, n, x,
                list(y3, y1, y2),
                list(
                  e = c(1, 6),
                  sesonal_sin = c(2, 5),
                  sesonal_cos = c(3, 4)
                    ),
                list(1:6),
                list(
                      trend = c(0, 1/12 - 4*eps),
                      # sesonal_sin = c(1/12-eps, 1/12+eps),
                      sesonal_sin = c(1/12-4*eps, 1/12+4*eps),
                      # sesonal_cos = c(1/3-eps, 1/3+eps)
                      sesonal_cos = c(1/3-4*eps, 1/2)
                    ),
                data
)
print(df)

df_to_latex_print(df)
```
